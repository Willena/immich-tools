/* tslint:disable */
/* eslint-disable */
/**
 * Immich
 * Immich API
 *
 * The version of the OpenAPI document: 1.91.4
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type {AxiosInstance, AxiosPromise, AxiosRequestConfig} from 'axios';
import globalAxios from 'axios';
import type {RequestArgs} from './base';
// @ts-ignore
import {BASE_PATH, BaseAPI, COLLECTION_FORMATS, RequiredError} from './base';
// Some imports not used depending on template conditions
// @ts-ignore
import {
    assertParamExists,
    createRequestFunction,
    DUMMY_BASE_URL,
    serializeDataIfNeeded,
    setApiKeyToObject,
    setBasicAuthToObject,
    setBearerAuthToObject,
    setOAuthToObject,
    setSearchParams,
    toPathString
} from './common';
import type {Configuration} from './configuration';

/**
 *
 * @export
 * @interface APIKeyCreateDto
 */
export interface APIKeyCreateDto {
    /**
     *
     * @type {string}
     * @memberof APIKeyCreateDto
     */
    'name'?: string;
}

/**
 *
 * @export
 * @interface APIKeyCreateResponseDto
 */
export interface APIKeyCreateResponseDto {
    /**
     *
     * @type {APIKeyResponseDto}
     * @memberof APIKeyCreateResponseDto
     */
    'apiKey': APIKeyResponseDto;
    /**
     *
     * @type {string}
     * @memberof APIKeyCreateResponseDto
     */
    'secret': string;
}

/**
 *
 * @export
 * @interface APIKeyResponseDto
 */
export interface APIKeyResponseDto {
    /**
     *
     * @type {string}
     * @memberof APIKeyResponseDto
     */
    'createdAt': string;
    /**
     *
     * @type {string}
     * @memberof APIKeyResponseDto
     */
    'id': string;
    /**
     *
     * @type {string}
     * @memberof APIKeyResponseDto
     */
    'name': string;
    /**
     *
     * @type {string}
     * @memberof APIKeyResponseDto
     */
    'updatedAt': string;
}

/**
 *
 * @export
 * @interface APIKeyUpdateDto
 */
export interface APIKeyUpdateDto {
    /**
     *
     * @type {string}
     * @memberof APIKeyUpdateDto
     */
    'name': string;
}

/**
 *
 * @export
 * @interface ActivityCreateDto
 */
export interface ActivityCreateDto {
    /**
     *
     * @type {string}
     * @memberof ActivityCreateDto
     */
    'albumId': string;
    /**
     *
     * @type {string}
     * @memberof ActivityCreateDto
     */
    'assetId'?: string;
    /**
     *
     * @type {string}
     * @memberof ActivityCreateDto
     */
    'comment'?: string;
    /**
     *
     * @type {ReactionType}
     * @memberof ActivityCreateDto
     */
    'type': ReactionType;
}


/**
 *
 * @export
 * @interface ActivityResponseDto
 */
export interface ActivityResponseDto {
    /**
     *
     * @type {string}
     * @memberof ActivityResponseDto
     */
    'assetId': string | null;
    /**
     *
     * @type {string}
     * @memberof ActivityResponseDto
     */
    'comment'?: string | null;
    /**
     *
     * @type {string}
     * @memberof ActivityResponseDto
     */
    'createdAt': string;
    /**
     *
     * @type {string}
     * @memberof ActivityResponseDto
     */
    'id': string;
    /**
     *
     * @type {string}
     * @memberof ActivityResponseDto
     */
    'type': ActivityResponseDtoTypeEnum;
    /**
     *
     * @type {UserDto}
     * @memberof ActivityResponseDto
     */
    'user': UserDto;
}

export const ActivityResponseDtoTypeEnum = {
    Comment: 'comment',
    Like: 'like'
} as const;

export type ActivityResponseDtoTypeEnum = typeof ActivityResponseDtoTypeEnum[keyof typeof ActivityResponseDtoTypeEnum];

/**
 *
 * @export
 * @interface ActivityStatisticsResponseDto
 */
export interface ActivityStatisticsResponseDto {
    /**
     *
     * @type {number}
     * @memberof ActivityStatisticsResponseDto
     */
    'comments': number;
}

/**
 *
 * @export
 * @interface AddUsersDto
 */
export interface AddUsersDto {
    /**
     *
     * @type {Array<string>}
     * @memberof AddUsersDto
     */
    'sharedUserIds': Array<string>;
}

/**
 *
 * @export
 * @interface AlbumCountResponseDto
 */
export interface AlbumCountResponseDto {
    /**
     *
     * @type {number}
     * @memberof AlbumCountResponseDto
     */
    'notShared': number;
    /**
     *
     * @type {number}
     * @memberof AlbumCountResponseDto
     */
    'owned': number;
    /**
     *
     * @type {number}
     * @memberof AlbumCountResponseDto
     */
    'shared': number;
}

/**
 *
 * @export
 * @interface AlbumResponseDto
 */
export interface AlbumResponseDto {
    /**
     *
     * @type {string}
     * @memberof AlbumResponseDto
     */
    'albumName': string;
    /**
     *
     * @type {string}
     * @memberof AlbumResponseDto
     */
    'albumThumbnailAssetId': string | null;
    /**
     *
     * @type {number}
     * @memberof AlbumResponseDto
     */
    'assetCount': number;
    /**
     *
     * @type {Array<AssetResponseDto>}
     * @memberof AlbumResponseDto
     */
    'assets': Array<AssetResponseDto>;
    /**
     *
     * @type {string}
     * @memberof AlbumResponseDto
     */
    'createdAt': string;
    /**
     *
     * @type {string}
     * @memberof AlbumResponseDto
     */
    'description': string;
    /**
     *
     * @type {string}
     * @memberof AlbumResponseDto
     */
    'endDate'?: string;
    /**
     *
     * @type {boolean}
     * @memberof AlbumResponseDto
     */
    'hasSharedLink': boolean;
    /**
     *
     * @type {string}
     * @memberof AlbumResponseDto
     */
    'id': string;
    /**
     *
     * @type {boolean}
     * @memberof AlbumResponseDto
     */
    'isActivityEnabled': boolean;
    /**
     *
     * @type {string}
     * @memberof AlbumResponseDto
     */
    'lastModifiedAssetTimestamp'?: string;
    /**
     *
     * @type {UserResponseDto}
     * @memberof AlbumResponseDto
     */
    'owner': UserResponseDto;
    /**
     *
     * @type {string}
     * @memberof AlbumResponseDto
     */
    'ownerId': string;
    /**
     *
     * @type {boolean}
     * @memberof AlbumResponseDto
     */
    'shared': boolean;
    /**
     *
     * @type {Array<UserResponseDto>}
     * @memberof AlbumResponseDto
     */
    'sharedUsers': Array<UserResponseDto>;
    /**
     *
     * @type {string}
     * @memberof AlbumResponseDto
     */
    'startDate'?: string;
    /**
     *
     * @type {string}
     * @memberof AlbumResponseDto
     */
    'updatedAt': string;
}

/**
 *
 * @export
 * @interface AllJobStatusResponseDto
 */
export interface AllJobStatusResponseDto {
    /**
     *
     * @type {JobStatusDto}
     * @memberof AllJobStatusResponseDto
     */
    'backgroundTask': JobStatusDto;
    /**
     *
     * @type {JobStatusDto}
     * @memberof AllJobStatusResponseDto
     */
    'library': JobStatusDto;
    /**
     *
     * @type {JobStatusDto}
     * @memberof AllJobStatusResponseDto
     */
    'metadataExtraction': JobStatusDto;
    /**
     *
     * @type {JobStatusDto}
     * @memberof AllJobStatusResponseDto
     */
    'migration': JobStatusDto;
    /**
     *
     * @type {JobStatusDto}
     * @memberof AllJobStatusResponseDto
     */
    'objectTagging': JobStatusDto;
    /**
     *
     * @type {JobStatusDto}
     * @memberof AllJobStatusResponseDto
     */
    'recognizeFaces': JobStatusDto;
    /**
     *
     * @type {JobStatusDto}
     * @memberof AllJobStatusResponseDto
     */
    'search': JobStatusDto;
    /**
     *
     * @type {JobStatusDto}
     * @memberof AllJobStatusResponseDto
     */
    'sidecar': JobStatusDto;
    /**
     *
     * @type {JobStatusDto}
     * @memberof AllJobStatusResponseDto
     */
    'smartSearch': JobStatusDto;
    /**
     *
     * @type {JobStatusDto}
     * @memberof AllJobStatusResponseDto
     */
    'storageTemplateMigration': JobStatusDto;
    /**
     *
     * @type {JobStatusDto}
     * @memberof AllJobStatusResponseDto
     */
    'thumbnailGeneration': JobStatusDto;
    /**
     *
     * @type {JobStatusDto}
     * @memberof AllJobStatusResponseDto
     */
    'videoConversion': JobStatusDto;
}

/**
 *
 * @export
 * @interface AssetBulkDeleteDto
 */
export interface AssetBulkDeleteDto {
    /**
     *
     * @type {boolean}
     * @memberof AssetBulkDeleteDto
     */
    'force'?: boolean;
    /**
     *
     * @type {Array<string>}
     * @memberof AssetBulkDeleteDto
     */
    'ids': Array<string>;
}

/**
 *
 * @export
 * @interface AssetBulkUpdateDto
 */
export interface AssetBulkUpdateDto {
    /**
     *
     * @type {string}
     * @memberof AssetBulkUpdateDto
     */
    'dateTimeOriginal'?: string;
    /**
     *
     * @type {Array<string>}
     * @memberof AssetBulkUpdateDto
     */
    'ids': Array<string>;
    /**
     *
     * @type {boolean}
     * @memberof AssetBulkUpdateDto
     */
    'isArchived'?: boolean;
    /**
     *
     * @type {boolean}
     * @memberof AssetBulkUpdateDto
     */
    'isFavorite'?: boolean;
    /**
     *
     * @type {number}
     * @memberof AssetBulkUpdateDto
     */
    'latitude'?: number;
    /**
     *
     * @type {number}
     * @memberof AssetBulkUpdateDto
     */
    'longitude'?: number;
    /**
     *
     * @type {boolean}
     * @memberof AssetBulkUpdateDto
     */
    'removeParent'?: boolean;
    /**
     *
     * @type {string}
     * @memberof AssetBulkUpdateDto
     */
    'stackParentId'?: string;
}

/**
 *
 * @export
 * @interface AssetBulkUploadCheckDto
 */
export interface AssetBulkUploadCheckDto {
    /**
     *
     * @type {Array<AssetBulkUploadCheckItem>}
     * @memberof AssetBulkUploadCheckDto
     */
    'assets': Array<AssetBulkUploadCheckItem>;
}

/**
 *
 * @export
 * @interface AssetBulkUploadCheckItem
 */
export interface AssetBulkUploadCheckItem {
    /**
     * base64 or hex encoded sha1 hash
     * @type {string}
     * @memberof AssetBulkUploadCheckItem
     */
    'checksum': string;
    /**
     *
     * @type {string}
     * @memberof AssetBulkUploadCheckItem
     */
    'id': string;
}

/**
 *
 * @export
 * @interface AssetBulkUploadCheckResponseDto
 */
export interface AssetBulkUploadCheckResponseDto {
    /**
     *
     * @type {Array<AssetBulkUploadCheckResult>}
     * @memberof AssetBulkUploadCheckResponseDto
     */
    'results': Array<AssetBulkUploadCheckResult>;
}

/**
 *
 * @export
 * @interface AssetBulkUploadCheckResult
 */
export interface AssetBulkUploadCheckResult {
    /**
     *
     * @type {string}
     * @memberof AssetBulkUploadCheckResult
     */
    'action': AssetBulkUploadCheckResultActionEnum;
    /**
     *
     * @type {string}
     * @memberof AssetBulkUploadCheckResult
     */
    'assetId'?: string;
    /**
     *
     * @type {string}
     * @memberof AssetBulkUploadCheckResult
     */
    'id': string;
    /**
     *
     * @type {string}
     * @memberof AssetBulkUploadCheckResult
     */
    'reason'?: AssetBulkUploadCheckResultReasonEnum;
}

export const AssetBulkUploadCheckResultActionEnum = {
    Accept: 'accept',
    Reject: 'reject'
} as const;

export type AssetBulkUploadCheckResultActionEnum = typeof AssetBulkUploadCheckResultActionEnum[keyof typeof AssetBulkUploadCheckResultActionEnum];
export const AssetBulkUploadCheckResultReasonEnum = {
    Duplicate: 'duplicate',
    UnsupportedFormat: 'unsupported-format'
} as const;

export type AssetBulkUploadCheckResultReasonEnum = typeof AssetBulkUploadCheckResultReasonEnum[keyof typeof AssetBulkUploadCheckResultReasonEnum];

/**
 *
 * @export
 * @interface AssetFaceResponseDto
 */
export interface AssetFaceResponseDto {
    /**
     *
     * @type {number}
     * @memberof AssetFaceResponseDto
     */
    'boundingBoxX1': number;
    /**
     *
     * @type {number}
     * @memberof AssetFaceResponseDto
     */
    'boundingBoxX2': number;
    /**
     *
     * @type {number}
     * @memberof AssetFaceResponseDto
     */
    'boundingBoxY1': number;
    /**
     *
     * @type {number}
     * @memberof AssetFaceResponseDto
     */
    'boundingBoxY2': number;
    /**
     *
     * @type {string}
     * @memberof AssetFaceResponseDto
     */
    'id': string;
    /**
     *
     * @type {number}
     * @memberof AssetFaceResponseDto
     */
    'imageHeight': number;
    /**
     *
     * @type {number}
     * @memberof AssetFaceResponseDto
     */
    'imageWidth': number;
    /**
     *
     * @type {PersonResponseDto}
     * @memberof AssetFaceResponseDto
     */
    'person': PersonResponseDto | null;
}

/**
 *
 * @export
 * @interface AssetFaceUpdateDto
 */
export interface AssetFaceUpdateDto {
    /**
     *
     * @type {Array<AssetFaceUpdateItem>}
     * @memberof AssetFaceUpdateDto
     */
    'data': Array<AssetFaceUpdateItem>;
}

/**
 *
 * @export
 * @interface AssetFaceUpdateItem
 */
export interface AssetFaceUpdateItem {
    /**
     *
     * @type {string}
     * @memberof AssetFaceUpdateItem
     */
    'assetId': string;
    /**
     *
     * @type {string}
     * @memberof AssetFaceUpdateItem
     */
    'personId': string;
}

/**
 *
 * @export
 * @interface AssetFaceWithoutPersonResponseDto
 */
export interface AssetFaceWithoutPersonResponseDto {
    /**
     *
     * @type {number}
     * @memberof AssetFaceWithoutPersonResponseDto
     */
    'boundingBoxX1': number;
    /**
     *
     * @type {number}
     * @memberof AssetFaceWithoutPersonResponseDto
     */
    'boundingBoxX2': number;
    /**
     *
     * @type {number}
     * @memberof AssetFaceWithoutPersonResponseDto
     */
    'boundingBoxY1': number;
    /**
     *
     * @type {number}
     * @memberof AssetFaceWithoutPersonResponseDto
     */
    'boundingBoxY2': number;
    /**
     *
     * @type {string}
     * @memberof AssetFaceWithoutPersonResponseDto
     */
    'id': string;
    /**
     *
     * @type {number}
     * @memberof AssetFaceWithoutPersonResponseDto
     */
    'imageHeight': number;
    /**
     *
     * @type {number}
     * @memberof AssetFaceWithoutPersonResponseDto
     */
    'imageWidth': number;
}

/**
 *
 * @export
 * @interface AssetFileUploadResponseDto
 */
export interface AssetFileUploadResponseDto {
    /**
     *
     * @type {boolean}
     * @memberof AssetFileUploadResponseDto
     */
    'duplicate': boolean;
    /**
     *
     * @type {string}
     * @memberof AssetFileUploadResponseDto
     */
    'id': string;
}

/**
 *
 * @export
 * @interface AssetIdsDto
 */
export interface AssetIdsDto {
    /**
     *
     * @type {Array<string>}
     * @memberof AssetIdsDto
     */
    'assetIds': Array<string>;
}

/**
 *
 * @export
 * @interface AssetIdsResponseDto
 */
export interface AssetIdsResponseDto {
    /**
     *
     * @type {string}
     * @memberof AssetIdsResponseDto
     */
    'assetId': string;
    /**
     *
     * @type {string}
     * @memberof AssetIdsResponseDto
     */
    'error'?: AssetIdsResponseDtoErrorEnum;
    /**
     *
     * @type {boolean}
     * @memberof AssetIdsResponseDto
     */
    'success': boolean;
}

export const AssetIdsResponseDtoErrorEnum = {
    Duplicate: 'duplicate',
    NoPermission: 'no_permission',
    NotFound: 'not_found'
} as const;

export type AssetIdsResponseDtoErrorEnum = typeof AssetIdsResponseDtoErrorEnum[keyof typeof AssetIdsResponseDtoErrorEnum];

/**
 *
 * @export
 * @enum {string}
 */

export const AssetJobName = {
    RegenerateThumbnail: 'regenerate-thumbnail',
    RefreshMetadata: 'refresh-metadata',
    TranscodeVideo: 'transcode-video'
} as const;

export type AssetJobName = typeof AssetJobName[keyof typeof AssetJobName];


/**
 *
 * @export
 * @interface AssetJobsDto
 */
export interface AssetJobsDto {
    /**
     *
     * @type {Array<string>}
     * @memberof AssetJobsDto
     */
    'assetIds': Array<string>;
    /**
     *
     * @type {AssetJobName}
     * @memberof AssetJobsDto
     */
    'name': AssetJobName;
}


/**
 *
 * @export
 * @enum {string}
 */

export const AssetOrder = {
    Asc: 'asc',
    Desc: 'desc'
} as const;

export type AssetOrder = typeof AssetOrder[keyof typeof AssetOrder];


/**
 *
 * @export
 * @interface AssetResponseDto
 */
export interface AssetResponseDto {
    /**
     * base64 encoded sha1 hash
     * @type {string}
     * @memberof AssetResponseDto
     */
    'checksum': string;
    /**
     *
     * @type {string}
     * @memberof AssetResponseDto
     */
    'deviceAssetId': string;
    /**
     *
     * @type {string}
     * @memberof AssetResponseDto
     */
    'deviceId': string;
    /**
     *
     * @type {string}
     * @memberof AssetResponseDto
     */
    'duration': string;
    /**
     *
     * @type {ExifResponseDto}
     * @memberof AssetResponseDto
     */
    'exifInfo'?: ExifResponseDto;
    /**
     *
     * @type {string}
     * @memberof AssetResponseDto
     */
    'fileCreatedAt': string;
    /**
     *
     * @type {string}
     * @memberof AssetResponseDto
     */
    'fileModifiedAt': string;
    /**
     *
     * @type {boolean}
     * @memberof AssetResponseDto
     */
    'hasMetadata': boolean;
    /**
     *
     * @type {string}
     * @memberof AssetResponseDto
     */
    'id': string;
    /**
     *
     * @type {boolean}
     * @memberof AssetResponseDto
     */
    'isArchived': boolean;
    /**
     *
     * @type {boolean}
     * @memberof AssetResponseDto
     */
    'isExternal': boolean;
    /**
     *
     * @type {boolean}
     * @memberof AssetResponseDto
     */
    'isFavorite': boolean;
    /**
     *
     * @type {boolean}
     * @memberof AssetResponseDto
     */
    'isOffline': boolean;
    /**
     *
     * @type {boolean}
     * @memberof AssetResponseDto
     */
    'isReadOnly': boolean;
    /**
     *
     * @type {boolean}
     * @memberof AssetResponseDto
     */
    'isTrashed': boolean;
    /**
     *
     * @type {string}
     * @memberof AssetResponseDto
     */
    'libraryId': string;
    /**
     *
     * @type {string}
     * @memberof AssetResponseDto
     */
    'livePhotoVideoId'?: string | null;
    /**
     *
     * @type {string}
     * @memberof AssetResponseDto
     */
    'localDateTime': string;
    /**
     *
     * @type {string}
     * @memberof AssetResponseDto
     */
    'originalFileName': string;
    /**
     *
     * @type {string}
     * @memberof AssetResponseDto
     */
    'originalPath': string;
    /**
     *
     * @type {UserResponseDto}
     * @memberof AssetResponseDto
     */
    'owner'?: UserResponseDto;
    /**
     *
     * @type {string}
     * @memberof AssetResponseDto
     */
    'ownerId': string;
    /**
     *
     * @type {Array<PersonWithFacesResponseDto>}
     * @memberof AssetResponseDto
     */
    'people'?: Array<PersonWithFacesResponseDto>;
    /**
     *
     * @type {boolean}
     * @memberof AssetResponseDto
     */
    'resized': boolean;
    /**
     *
     * @type {SmartInfoResponseDto}
     * @memberof AssetResponseDto
     */
    'smartInfo'?: SmartInfoResponseDto;
    /**
     *
     * @type {Array<AssetResponseDto>}
     * @memberof AssetResponseDto
     */
    'stack'?: Array<AssetResponseDto>;
    /**
     *
     * @type {number}
     * @memberof AssetResponseDto
     */
    'stackCount': number | null;
    /**
     *
     * @type {string}
     * @memberof AssetResponseDto
     */
    'stackParentId'?: string | null;
    /**
     *
     * @type {Array<TagResponseDto>}
     * @memberof AssetResponseDto
     */
    'tags'?: Array<TagResponseDto>;
    /**
     *
     * @type {string}
     * @memberof AssetResponseDto
     */
    'thumbhash': string | null;
    /**
     *
     * @type {AssetTypeEnum}
     * @memberof AssetResponseDto
     */
    'type': AssetTypeEnum;
    /**
     *
     * @type {string}
     * @memberof AssetResponseDto
     */
    'updatedAt': string;
}


/**
 *
 * @export
 * @interface AssetStatsResponseDto
 */
export interface AssetStatsResponseDto {
    /**
     *
     * @type {number}
     * @memberof AssetStatsResponseDto
     */
    'images': number;
    /**
     *
     * @type {number}
     * @memberof AssetStatsResponseDto
     */
    'total': number;
    /**
     *
     * @type {number}
     * @memberof AssetStatsResponseDto
     */
    'videos': number;
}

/**
 *
 * @export
 * @enum {string}
 */

export const AssetTypeEnum = {
    Image: 'IMAGE',
    Video: 'VIDEO',
    Audio: 'AUDIO',
    Other: 'OTHER'
} as const;

export type AssetTypeEnum = typeof AssetTypeEnum[keyof typeof AssetTypeEnum];


/**
 *
 * @export
 * @enum {string}
 */

export const AudioCodec = {
    Mp3: 'mp3',
    Aac: 'aac',
    Libopus: 'libopus'
} as const;

export type AudioCodec = typeof AudioCodec[keyof typeof AudioCodec];


/**
 *
 * @export
 * @interface AuditDeletesResponseDto
 */
export interface AuditDeletesResponseDto {
    /**
     *
     * @type {Array<string>}
     * @memberof AuditDeletesResponseDto
     */
    'ids': Array<string>;
    /**
     *
     * @type {boolean}
     * @memberof AuditDeletesResponseDto
     */
    'needsFullSync': boolean;
}

/**
 *
 * @export
 * @interface AuthDeviceResponseDto
 */
export interface AuthDeviceResponseDto {
    /**
     *
     * @type {string}
     * @memberof AuthDeviceResponseDto
     */
    'createdAt': string;
    /**
     *
     * @type {boolean}
     * @memberof AuthDeviceResponseDto
     */
    'current': boolean;
    /**
     *
     * @type {string}
     * @memberof AuthDeviceResponseDto
     */
    'deviceOS': string;
    /**
     *
     * @type {string}
     * @memberof AuthDeviceResponseDto
     */
    'deviceType': string;
    /**
     *
     * @type {string}
     * @memberof AuthDeviceResponseDto
     */
    'id': string;
    /**
     *
     * @type {string}
     * @memberof AuthDeviceResponseDto
     */
    'updatedAt': string;
}

/**
 *
 * @export
 * @interface BulkIdResponseDto
 */
export interface BulkIdResponseDto {
    /**
     *
     * @type {string}
     * @memberof BulkIdResponseDto
     */
    'error'?: BulkIdResponseDtoErrorEnum;
    /**
     *
     * @type {string}
     * @memberof BulkIdResponseDto
     */
    'id': string;
    /**
     *
     * @type {boolean}
     * @memberof BulkIdResponseDto
     */
    'success': boolean;
}

export const BulkIdResponseDtoErrorEnum = {
    Duplicate: 'duplicate',
    NoPermission: 'no_permission',
    NotFound: 'not_found',
    Unknown: 'unknown'
} as const;

export type BulkIdResponseDtoErrorEnum = typeof BulkIdResponseDtoErrorEnum[keyof typeof BulkIdResponseDtoErrorEnum];

/**
 *
 * @export
 * @interface BulkIdsDto
 */
export interface BulkIdsDto {
    /**
     *
     * @type {Array<string>}
     * @memberof BulkIdsDto
     */
    'ids': Array<string>;
}

/**
 *
 * @export
 * @interface CLIPConfig
 */
export interface CLIPConfig {
    /**
     *
     * @type {boolean}
     * @memberof CLIPConfig
     */
    'enabled': boolean;
    /**
     *
     * @type {CLIPMode}
     * @memberof CLIPConfig
     */
    'mode'?: CLIPMode;
    /**
     *
     * @type {string}
     * @memberof CLIPConfig
     */
    'modelName': string;
    /**
     *
     * @type {ModelType}
     * @memberof CLIPConfig
     */
    'modelType'?: ModelType;
}


/**
 *
 * @export
 * @enum {string}
 */

export const CLIPMode = {
    Vision: 'vision',
    Text: 'text'
} as const;

export type CLIPMode = typeof CLIPMode[keyof typeof CLIPMode];


/**
 *
 * @export
 * @enum {string}
 */

export const CQMode = {
    Auto: 'auto',
    Cqp: 'cqp',
    Icq: 'icq'
} as const;

export type CQMode = typeof CQMode[keyof typeof CQMode];


/**
 *
 * @export
 * @interface ChangePasswordDto
 */
export interface ChangePasswordDto {
    /**
     *
     * @type {string}
     * @memberof ChangePasswordDto
     */
    'newPassword': string;
    /**
     *
     * @type {string}
     * @memberof ChangePasswordDto
     */
    'password': string;
}

/**
 *
 * @export
 * @interface CheckExistingAssetsDto
 */
export interface CheckExistingAssetsDto {
    /**
     *
     * @type {Array<string>}
     * @memberof CheckExistingAssetsDto
     */
    'deviceAssetIds': Array<string>;
    /**
     *
     * @type {string}
     * @memberof CheckExistingAssetsDto
     */
    'deviceId': string;
}

/**
 *
 * @export
 * @interface CheckExistingAssetsResponseDto
 */
export interface CheckExistingAssetsResponseDto {
    /**
     *
     * @type {Array<string>}
     * @memberof CheckExistingAssetsResponseDto
     */
    'existingIds': Array<string>;
}

/**
 *
 * @export
 * @interface ClassificationConfig
 */
export interface ClassificationConfig {
    /**
     *
     * @type {boolean}
     * @memberof ClassificationConfig
     */
    'enabled': boolean;
    /**
     *
     * @type {number}
     * @memberof ClassificationConfig
     */
    'minScore': number;
    /**
     *
     * @type {string}
     * @memberof ClassificationConfig
     */
    'modelName': string;
    /**
     *
     * @type {ModelType}
     * @memberof ClassificationConfig
     */
    'modelType'?: ModelType;
}


/**
 *
 * @export
 * @enum {string}
 */

export const Colorspace = {
    Srgb: 'srgb',
    P3: 'p3'
} as const;

export type Colorspace = typeof Colorspace[keyof typeof Colorspace];


/**
 *
 * @export
 * @interface CreateAlbumDto
 */
export interface CreateAlbumDto {
    /**
     *
     * @type {string}
     * @memberof CreateAlbumDto
     */
    'albumName': string;
    /**
     *
     * @type {Array<string>}
     * @memberof CreateAlbumDto
     */
    'assetIds'?: Array<string>;
    /**
     *
     * @type {string}
     * @memberof CreateAlbumDto
     */
    'description'?: string;
    /**
     *
     * @type {Array<string>}
     * @memberof CreateAlbumDto
     */
    'sharedWithUserIds'?: Array<string>;
}

/**
 *
 * @export
 * @interface CreateLibraryDto
 */
export interface CreateLibraryDto {
    /**
     *
     * @type {Array<string>}
     * @memberof CreateLibraryDto
     */
    'exclusionPatterns'?: Array<string>;
    /**
     *
     * @type {Array<string>}
     * @memberof CreateLibraryDto
     */
    'importPaths'?: Array<string>;
    /**
     *
     * @type {boolean}
     * @memberof CreateLibraryDto
     */
    'isVisible'?: boolean;
    /**
     *
     * @type {string}
     * @memberof CreateLibraryDto
     */
    'name'?: string;
    /**
     *
     * @type {LibraryType}
     * @memberof CreateLibraryDto
     */
    'type': LibraryType;
}


/**
 *
 * @export
 * @interface CreateProfileImageResponseDto
 */
export interface CreateProfileImageResponseDto {
    /**
     *
     * @type {string}
     * @memberof CreateProfileImageResponseDto
     */
    'profileImagePath': string;
    /**
     *
     * @type {string}
     * @memberof CreateProfileImageResponseDto
     */
    'userId': string;
}

/**
 *
 * @export
 * @interface CreateTagDto
 */
export interface CreateTagDto {
    /**
     *
     * @type {string}
     * @memberof CreateTagDto
     */
    'name': string;
    /**
     *
     * @type {TagTypeEnum}
     * @memberof CreateTagDto
     */
    'type': TagTypeEnum;
}


/**
 *
 * @export
 * @interface CreateUserDto
 */
export interface CreateUserDto {
    /**
     *
     * @type {string}
     * @memberof CreateUserDto
     */
    'email': string;
    /**
     *
     * @type {string}
     * @memberof CreateUserDto
     */
    'externalPath'?: string | null;
    /**
     *
     * @type {boolean}
     * @memberof CreateUserDto
     */
    'memoriesEnabled'?: boolean;
    /**
     *
     * @type {string}
     * @memberof CreateUserDto
     */
    'name': string;
    /**
     *
     * @type {string}
     * @memberof CreateUserDto
     */
    'password': string;
    /**
     *
     * @type {string}
     * @memberof CreateUserDto
     */
    'storageLabel'?: string | null;
}

/**
 *
 * @export
 * @interface CuratedLocationsResponseDto
 */
export interface CuratedLocationsResponseDto {
    /**
     *
     * @type {string}
     * @memberof CuratedLocationsResponseDto
     */
    'city': string;
    /**
     *
     * @type {string}
     * @memberof CuratedLocationsResponseDto
     */
    'deviceAssetId': string;
    /**
     *
     * @type {string}
     * @memberof CuratedLocationsResponseDto
     */
    'deviceId': string;
    /**
     *
     * @type {string}
     * @memberof CuratedLocationsResponseDto
     */
    'id': string;
    /**
     *
     * @type {string}
     * @memberof CuratedLocationsResponseDto
     */
    'resizePath': string;
}

/**
 *
 * @export
 * @interface CuratedObjectsResponseDto
 */
export interface CuratedObjectsResponseDto {
    /**
     *
     * @type {string}
     * @memberof CuratedObjectsResponseDto
     */
    'deviceAssetId': string;
    /**
     *
     * @type {string}
     * @memberof CuratedObjectsResponseDto
     */
    'deviceId': string;
    /**
     *
     * @type {string}
     * @memberof CuratedObjectsResponseDto
     */
    'id': string;
    /**
     *
     * @type {string}
     * @memberof CuratedObjectsResponseDto
     */
    'object': string;
    /**
     *
     * @type {string}
     * @memberof CuratedObjectsResponseDto
     */
    'resizePath': string;
}

/**
 *
 * @export
 * @interface DownloadArchiveInfo
 */
export interface DownloadArchiveInfo {
    /**
     *
     * @type {Array<string>}
     * @memberof DownloadArchiveInfo
     */
    'assetIds': Array<string>;
    /**
     *
     * @type {number}
     * @memberof DownloadArchiveInfo
     */
    'size': number;
}

/**
 *
 * @export
 * @interface DownloadInfoDto
 */
export interface DownloadInfoDto {
    /**
     *
     * @type {string}
     * @memberof DownloadInfoDto
     */
    'albumId'?: string;
    /**
     *
     * @type {number}
     * @memberof DownloadInfoDto
     */
    'archiveSize'?: number;
    /**
     *
     * @type {Array<string>}
     * @memberof DownloadInfoDto
     */
    'assetIds'?: Array<string>;
    /**
     *
     * @type {string}
     * @memberof DownloadInfoDto
     */
    'userId'?: string;
}

/**
 *
 * @export
 * @interface DownloadResponseDto
 */
export interface DownloadResponseDto {
    /**
     *
     * @type {Array<DownloadArchiveInfo>}
     * @memberof DownloadResponseDto
     */
    'archives': Array<DownloadArchiveInfo>;
    /**
     *
     * @type {number}
     * @memberof DownloadResponseDto
     */
    'totalSize': number;
}

/**
 *
 * @export
 * @enum {string}
 */

export const EntityType = {
    Asset: 'ASSET',
    Album: 'ALBUM'
} as const;

export type EntityType = typeof EntityType[keyof typeof EntityType];


/**
 *
 * @export
 * @interface ExifResponseDto
 */
export interface ExifResponseDto {
    /**
     *
     * @type {string}
     * @memberof ExifResponseDto
     */
    'city'?: string | null;
    /**
     *
     * @type {string}
     * @memberof ExifResponseDto
     */
    'country'?: string | null;
    /**
     *
     * @type {string}
     * @memberof ExifResponseDto
     */
    'dateTimeOriginal'?: string | null;
    /**
     *
     * @type {string}
     * @memberof ExifResponseDto
     */
    'description'?: string | null;
    /**
     *
     * @type {number}
     * @memberof ExifResponseDto
     */
    'exifImageHeight'?: number | null;
    /**
     *
     * @type {number}
     * @memberof ExifResponseDto
     */
    'exifImageWidth'?: number | null;
    /**
     *
     * @type {string}
     * @memberof ExifResponseDto
     */
    'exposureTime'?: string | null;
    /**
     *
     * @type {number}
     * @memberof ExifResponseDto
     */
    'fNumber'?: number | null;
    /**
     *
     * @type {number}
     * @memberof ExifResponseDto
     */
    'fileSizeInByte'?: number | null;
    /**
     *
     * @type {number}
     * @memberof ExifResponseDto
     */
    'focalLength'?: number | null;
    /**
     *
     * @type {number}
     * @memberof ExifResponseDto
     */
    'iso'?: number | null;
    /**
     *
     * @type {number}
     * @memberof ExifResponseDto
     */
    'latitude'?: number | null;
    /**
     *
     * @type {string}
     * @memberof ExifResponseDto
     */
    'lensModel'?: string | null;
    /**
     *
     * @type {number}
     * @memberof ExifResponseDto
     */
    'longitude'?: number | null;
    /**
     *
     * @type {string}
     * @memberof ExifResponseDto
     */
    'make'?: string | null;
    /**
     *
     * @type {string}
     * @memberof ExifResponseDto
     */
    'model'?: string | null;
    /**
     *
     * @type {string}
     * @memberof ExifResponseDto
     */
    'modifyDate'?: string | null;
    /**
     *
     * @type {string}
     * @memberof ExifResponseDto
     */
    'orientation'?: string | null;
    /**
     *
     * @type {string}
     * @memberof ExifResponseDto
     */
    'projectionType'?: string | null;
    /**
     *
     * @type {string}
     * @memberof ExifResponseDto
     */
    'state'?: string | null;
    /**
     *
     * @type {string}
     * @memberof ExifResponseDto
     */
    'timeZone'?: string | null;
}

/**
 *
 * @export
 * @interface FaceDto
 */
export interface FaceDto {
    /**
     *
     * @type {string}
     * @memberof FaceDto
     */
    'id': string;
}

/**
 *
 * @export
 * @interface FileChecksumDto
 */
export interface FileChecksumDto {
    /**
     *
     * @type {Array<string>}
     * @memberof FileChecksumDto
     */
    'filenames': Array<string>;
}

/**
 *
 * @export
 * @interface FileChecksumResponseDto
 */
export interface FileChecksumResponseDto {
    /**
     *
     * @type {string}
     * @memberof FileChecksumResponseDto
     */
    'checksum': string;
    /**
     *
     * @type {string}
     * @memberof FileChecksumResponseDto
     */
    'filename': string;
}

/**
 *
 * @export
 * @interface FileReportDto
 */
export interface FileReportDto {
    /**
     *
     * @type {Array<string>}
     * @memberof FileReportDto
     */
    'extras': Array<string>;
    /**
     *
     * @type {Array<FileReportItemDto>}
     * @memberof FileReportDto
     */
    'orphans': Array<FileReportItemDto>;
}

/**
 *
 * @export
 * @interface FileReportFixDto
 */
export interface FileReportFixDto {
    /**
     *
     * @type {Array<FileReportItemDto>}
     * @memberof FileReportFixDto
     */
    'items': Array<FileReportItemDto>;
}

/**
 *
 * @export
 * @interface FileReportItemDto
 */
export interface FileReportItemDto {
    /**
     *
     * @type {string}
     * @memberof FileReportItemDto
     */
    'checksum'?: string;
    /**
     *
     * @type {string}
     * @memberof FileReportItemDto
     */
    'entityId': string;
    /**
     *
     * @type {PathEntityType}
     * @memberof FileReportItemDto
     */
    'entityType': PathEntityType;
    /**
     *
     * @type {PathType}
     * @memberof FileReportItemDto
     */
    'pathType': PathType;
    /**
     *
     * @type {string}
     * @memberof FileReportItemDto
     */
    'pathValue': string;
}


/**
 *
 * @export
 * @enum {string}
 */

export const JobCommand = {
    Start: 'start',
    Pause: 'pause',
    Resume: 'resume',
    Empty: 'empty',
    ClearFailed: 'clear-failed'
} as const;

export type JobCommand = typeof JobCommand[keyof typeof JobCommand];


/**
 *
 * @export
 * @interface JobCommandDto
 */
export interface JobCommandDto {
    /**
     *
     * @type {JobCommand}
     * @memberof JobCommandDto
     */
    'command': JobCommand;
    /**
     *
     * @type {boolean}
     * @memberof JobCommandDto
     */
    'force': boolean;
}


/**
 *
 * @export
 * @interface JobCountsDto
 */
export interface JobCountsDto {
    /**
     *
     * @type {number}
     * @memberof JobCountsDto
     */
    'active': number;
    /**
     *
     * @type {number}
     * @memberof JobCountsDto
     */
    'completed': number;
    /**
     *
     * @type {number}
     * @memberof JobCountsDto
     */
    'delayed': number;
    /**
     *
     * @type {number}
     * @memberof JobCountsDto
     */
    'failed': number;
    /**
     *
     * @type {number}
     * @memberof JobCountsDto
     */
    'paused': number;
    /**
     *
     * @type {number}
     * @memberof JobCountsDto
     */
    'waiting': number;
}

/**
 *
 * @export
 * @enum {string}
 */

export const JobName = {
    ThumbnailGeneration: 'thumbnailGeneration',
    MetadataExtraction: 'metadataExtraction',
    VideoConversion: 'videoConversion',
    ObjectTagging: 'objectTagging',
    RecognizeFaces: 'recognizeFaces',
    SmartSearch: 'smartSearch',
    BackgroundTask: 'backgroundTask',
    StorageTemplateMigration: 'storageTemplateMigration',
    Migration: 'migration',
    Search: 'search',
    Sidecar: 'sidecar',
    Library: 'library'
} as const;

export type JobName = typeof JobName[keyof typeof JobName];


/**
 *
 * @export
 * @interface JobSettingsDto
 */
export interface JobSettingsDto {
    /**
     *
     * @type {number}
     * @memberof JobSettingsDto
     */
    'concurrency': number;
}

/**
 *
 * @export
 * @interface JobStatusDto
 */
export interface JobStatusDto {
    /**
     *
     * @type {JobCountsDto}
     * @memberof JobStatusDto
     */
    'jobCounts': JobCountsDto;
    /**
     *
     * @type {QueueStatusDto}
     * @memberof JobStatusDto
     */
    'queueStatus': QueueStatusDto;
}

/**
 *
 * @export
 * @interface LibraryResponseDto
 */
export interface LibraryResponseDto {
    /**
     *
     * @type {number}
     * @memberof LibraryResponseDto
     */
    'assetCount': number;
    /**
     *
     * @type {string}
     * @memberof LibraryResponseDto
     */
    'createdAt': string;
    /**
     *
     * @type {Array<string>}
     * @memberof LibraryResponseDto
     */
    'exclusionPatterns': Array<string>;
    /**
     *
     * @type {string}
     * @memberof LibraryResponseDto
     */
    'id': string;
    /**
     *
     * @type {Array<string>}
     * @memberof LibraryResponseDto
     */
    'importPaths': Array<string>;
    /**
     *
     * @type {string}
     * @memberof LibraryResponseDto
     */
    'name': string;
    /**
     *
     * @type {string}
     * @memberof LibraryResponseDto
     */
    'ownerId': string;
    /**
     *
     * @type {string}
     * @memberof LibraryResponseDto
     */
    'refreshedAt': string | null;
    /**
     *
     * @type {LibraryType}
     * @memberof LibraryResponseDto
     */
    'type': LibraryType;
    /**
     *
     * @type {string}
     * @memberof LibraryResponseDto
     */
    'updatedAt': string;
}


/**
 *
 * @export
 * @interface LibraryStatsResponseDto
 */
export interface LibraryStatsResponseDto {
    /**
     *
     * @type {number}
     * @memberof LibraryStatsResponseDto
     */
    'photos': number;
    /**
     *
     * @type {number}
     * @memberof LibraryStatsResponseDto
     */
    'total': number;
    /**
     *
     * @type {number}
     * @memberof LibraryStatsResponseDto
     */
    'usage': number;
    /**
     *
     * @type {number}
     * @memberof LibraryStatsResponseDto
     */
    'videos': number;
}

/**
 *
 * @export
 * @enum {string}
 */

export const LibraryType = {
    Upload: 'UPLOAD',
    External: 'EXTERNAL'
} as const;

export type LibraryType = typeof LibraryType[keyof typeof LibraryType];


/**
 *
 * @export
 * @enum {string}
 */

export const LogLevel = {
    Verbose: 'verbose',
    Debug: 'debug',
    Log: 'log',
    Warn: 'warn',
    Error: 'error',
    Fatal: 'fatal'
} as const;

export type LogLevel = typeof LogLevel[keyof typeof LogLevel];


/**
 *
 * @export
 * @interface LoginCredentialDto
 */
export interface LoginCredentialDto {
    /**
     *
     * @type {string}
     * @memberof LoginCredentialDto
     */
    'email': string;
    /**
     *
     * @type {string}
     * @memberof LoginCredentialDto
     */
    'password': string;
}

/**
 *
 * @export
 * @interface LoginResponseDto
 */
export interface LoginResponseDto {
    /**
     *
     * @type {string}
     * @memberof LoginResponseDto
     */
    'accessToken': string;
    /**
     *
     * @type {boolean}
     * @memberof LoginResponseDto
     */
    'isAdmin': boolean;
    /**
     *
     * @type {string}
     * @memberof LoginResponseDto
     */
    'name': string;
    /**
     *
     * @type {string}
     * @memberof LoginResponseDto
     */
    'profileImagePath': string;
    /**
     *
     * @type {boolean}
     * @memberof LoginResponseDto
     */
    'shouldChangePassword': boolean;
    /**
     *
     * @type {string}
     * @memberof LoginResponseDto
     */
    'userEmail': string;
    /**
     *
     * @type {string}
     * @memberof LoginResponseDto
     */
    'userId': string;
}

/**
 *
 * @export
 * @interface LogoutResponseDto
 */
export interface LogoutResponseDto {
    /**
     *
     * @type {string}
     * @memberof LogoutResponseDto
     */
    'redirectUri': string;
    /**
     *
     * @type {boolean}
     * @memberof LogoutResponseDto
     */
    'successful': boolean;
}

/**
 *
 * @export
 * @interface MapMarkerResponseDto
 */
export interface MapMarkerResponseDto {
    /**
     *
     * @type {string}
     * @memberof MapMarkerResponseDto
     */
    'id': string;
    /**
     *
     * @type {number}
     * @memberof MapMarkerResponseDto
     */
    'lat': number;
    /**
     *
     * @type {number}
     * @memberof MapMarkerResponseDto
     */
    'lon': number;
}

/**
 *
 * @export
 * @enum {string}
 */

export const MapTheme = {
    Light: 'light',
    Dark: 'dark'
} as const;

export type MapTheme = typeof MapTheme[keyof typeof MapTheme];


/**
 *
 * @export
 * @interface MemoryLaneResponseDto
 */
export interface MemoryLaneResponseDto {
    /**
     *
     * @type {Array<AssetResponseDto>}
     * @memberof MemoryLaneResponseDto
     */
    'assets': Array<AssetResponseDto>;
    /**
     *
     * @type {string}
     * @memberof MemoryLaneResponseDto
     */
    'title': string;
}

/**
 *
 * @export
 * @interface MergePersonDto
 */
export interface MergePersonDto {
    /**
     *
     * @type {Array<string>}
     * @memberof MergePersonDto
     */
    'ids': Array<string>;
}

/**
 *
 * @export
 * @enum {string}
 */

export const ModelType = {
    ImageClassification: 'image-classification',
    FacialRecognition: 'facial-recognition',
    Clip: 'clip'
} as const;

export type ModelType = typeof ModelType[keyof typeof ModelType];


/**
 *
 * @export
 * @interface OAuthAuthorizeResponseDto
 */
export interface OAuthAuthorizeResponseDto {
    /**
     *
     * @type {string}
     * @memberof OAuthAuthorizeResponseDto
     */
    'url': string;
}

/**
 *
 * @export
 * @interface OAuthCallbackDto
 */
export interface OAuthCallbackDto {
    /**
     *
     * @type {string}
     * @memberof OAuthCallbackDto
     */
    'url': string;
}

/**
 *
 * @export
 * @interface OAuthConfigDto
 */
export interface OAuthConfigDto {
    /**
     *
     * @type {string}
     * @memberof OAuthConfigDto
     */
    'redirectUri': string;
}

/**
 *
 * @export
 * @interface OAuthConfigResponseDto
 */
export interface OAuthConfigResponseDto {
    /**
     *
     * @type {boolean}
     * @memberof OAuthConfigResponseDto
     */
    'autoLaunch'?: boolean;
    /**
     *
     * @type {string}
     * @memberof OAuthConfigResponseDto
     */
    'buttonText'?: string;
    /**
     *
     * @type {boolean}
     * @memberof OAuthConfigResponseDto
     */
    'enabled': boolean;
    /**
     *
     * @type {boolean}
     * @memberof OAuthConfigResponseDto
     */
    'passwordLoginEnabled': boolean;
    /**
     *
     * @type {string}
     * @memberof OAuthConfigResponseDto
     */
    'url'?: string;
}

/**
 *
 * @export
 * @interface PartnerResponseDto
 */
export interface PartnerResponseDto {
    /**
     *
     * @type {UserAvatarColor}
     * @memberof PartnerResponseDto
     */
    'avatarColor': UserAvatarColor;
    /**
     *
     * @type {string}
     * @memberof PartnerResponseDto
     */
    'createdAt': string;
    /**
     *
     * @type {string}
     * @memberof PartnerResponseDto
     */
    'deletedAt': string | null;
    /**
     *
     * @type {string}
     * @memberof PartnerResponseDto
     */
    'email': string;
    /**
     *
     * @type {string}
     * @memberof PartnerResponseDto
     */
    'externalPath': string | null;
    /**
     *
     * @type {string}
     * @memberof PartnerResponseDto
     */
    'id': string;
    /**
     *
     * @type {boolean}
     * @memberof PartnerResponseDto
     */
    'inTimeline'?: boolean;
    /**
     *
     * @type {boolean}
     * @memberof PartnerResponseDto
     */
    'isAdmin': boolean;
    /**
     *
     * @type {boolean}
     * @memberof PartnerResponseDto
     */
    'memoriesEnabled'?: boolean;
    /**
     *
     * @type {string}
     * @memberof PartnerResponseDto
     */
    'name': string;
    /**
     *
     * @type {string}
     * @memberof PartnerResponseDto
     */
    'oauthId': string;
    /**
     *
     * @type {string}
     * @memberof PartnerResponseDto
     */
    'profileImagePath': string;
    /**
     *
     * @type {boolean}
     * @memberof PartnerResponseDto
     */
    'shouldChangePassword': boolean;
    /**
     *
     * @type {string}
     * @memberof PartnerResponseDto
     */
    'storageLabel': string | null;
    /**
     *
     * @type {string}
     * @memberof PartnerResponseDto
     */
    'updatedAt': string;
}


/**
 *
 * @export
 * @enum {string}
 */

export const PathEntityType = {
    Asset: 'asset',
    Person: 'person',
    User: 'user'
} as const;

export type PathEntityType = typeof PathEntityType[keyof typeof PathEntityType];


/**
 *
 * @export
 * @enum {string}
 */

export const PathType = {
    Original: 'original',
    JpegThumbnail: 'jpeg_thumbnail',
    WebpThumbnail: 'webp_thumbnail',
    EncodedVideo: 'encoded_video',
    Sidecar: 'sidecar',
    Face: 'face',
    Profile: 'profile'
} as const;

export type PathType = typeof PathType[keyof typeof PathType];


/**
 *
 * @export
 * @interface PeopleResponseDto
 */
export interface PeopleResponseDto {
    /**
     *
     * @type {Array<PersonResponseDto>}
     * @memberof PeopleResponseDto
     */
    'people': Array<PersonResponseDto>;
    /**
     *
     * @type {number}
     * @memberof PeopleResponseDto
     */
    'total': number;
    /**
     *
     * @type {number}
     * @memberof PeopleResponseDto
     */
    'visible': number;
}

/**
 *
 * @export
 * @interface PeopleUpdateDto
 */
export interface PeopleUpdateDto {
    /**
     *
     * @type {Array<PeopleUpdateItem>}
     * @memberof PeopleUpdateDto
     */
    'people': Array<PeopleUpdateItem>;
}

/**
 *
 * @export
 * @interface PeopleUpdateItem
 */
export interface PeopleUpdateItem {
    /**
     * Person date of birth. Note: the mobile app cannot currently set the birth date to null.
     * @type {string}
     * @memberof PeopleUpdateItem
     */
    'birthDate'?: string | null;
    /**
     * Asset is used to get the feature face thumbnail.
     * @type {string}
     * @memberof PeopleUpdateItem
     */
    'featureFaceAssetId'?: string;
    /**
     * Person id.
     * @type {string}
     * @memberof PeopleUpdateItem
     */
    'id': string;
    /**
     * Person visibility
     * @type {boolean}
     * @memberof PeopleUpdateItem
     */
    'isHidden'?: boolean;
    /**
     * Person name.
     * @type {string}
     * @memberof PeopleUpdateItem
     */
    'name'?: string;
}

/**
 *
 * @export
 * @interface PersonResponseDto
 */
export interface PersonResponseDto {
    /**
     *
     * @type {string}
     * @memberof PersonResponseDto
     */
    'birthDate': string | null;
    /**
     *
     * @type {string}
     * @memberof PersonResponseDto
     */
    'id': string;
    /**
     *
     * @type {boolean}
     * @memberof PersonResponseDto
     */
    'isHidden': boolean;
    /**
     *
     * @type {string}
     * @memberof PersonResponseDto
     */
    'name': string;
    /**
     *
     * @type {string}
     * @memberof PersonResponseDto
     */
    'thumbnailPath': string;
}

/**
 *
 * @export
 * @interface PersonStatisticsResponseDto
 */
export interface PersonStatisticsResponseDto {
    /**
     *
     * @type {number}
     * @memberof PersonStatisticsResponseDto
     */
    'assets': number;
}

/**
 *
 * @export
 * @interface PersonUpdateDto
 */
export interface PersonUpdateDto {
    /**
     * Person date of birth. Note: the mobile app cannot currently set the birth date to null.
     * @type {string}
     * @memberof PersonUpdateDto
     */
    'birthDate'?: string | null;
    /**
     * Asset is used to get the feature face thumbnail.
     * @type {string}
     * @memberof PersonUpdateDto
     */
    'featureFaceAssetId'?: string;
    /**
     * Person visibility
     * @type {boolean}
     * @memberof PersonUpdateDto
     */
    'isHidden'?: boolean;
    /**
     * Person name.
     * @type {string}
     * @memberof PersonUpdateDto
     */
    'name'?: string;
}

/**
 *
 * @export
 * @interface PersonWithFacesResponseDto
 */
export interface PersonWithFacesResponseDto {
    /**
     *
     * @type {string}
     * @memberof PersonWithFacesResponseDto
     */
    'birthDate': string | null;
    /**
     *
     * @type {Array<AssetFaceWithoutPersonResponseDto>}
     * @memberof PersonWithFacesResponseDto
     */
    'faces': Array<AssetFaceWithoutPersonResponseDto>;
    /**
     *
     * @type {string}
     * @memberof PersonWithFacesResponseDto
     */
    'id': string;
    /**
     *
     * @type {boolean}
     * @memberof PersonWithFacesResponseDto
     */
    'isHidden': boolean;
    /**
     *
     * @type {string}
     * @memberof PersonWithFacesResponseDto
     */
    'name': string;
    /**
     *
     * @type {string}
     * @memberof PersonWithFacesResponseDto
     */
    'thumbnailPath': string;
}

/**
 *
 * @export
 * @interface QueueStatusDto
 */
export interface QueueStatusDto {
    /**
     *
     * @type {boolean}
     * @memberof QueueStatusDto
     */
    'isActive': boolean;
    /**
     *
     * @type {boolean}
     * @memberof QueueStatusDto
     */
    'isPaused': boolean;
}

/**
 *
 * @export
 * @enum {string}
 */

export const ReactionLevel = {
    Album: 'album',
    Asset: 'asset'
} as const;

export type ReactionLevel = typeof ReactionLevel[keyof typeof ReactionLevel];


/**
 *
 * @export
 * @enum {string}
 */

export const ReactionType = {
    Comment: 'comment',
    Like: 'like'
} as const;

export type ReactionType = typeof ReactionType[keyof typeof ReactionType];


/**
 *
 * @export
 * @interface RecognitionConfig
 */
export interface RecognitionConfig {
    /**
     *
     * @type {boolean}
     * @memberof RecognitionConfig
     */
    'enabled': boolean;
    /**
     *
     * @type {number}
     * @memberof RecognitionConfig
     */
    'maxDistance': number;
    /**
     *
     * @type {number}
     * @memberof RecognitionConfig
     */
    'minFaces': number;
    /**
     *
     * @type {number}
     * @memberof RecognitionConfig
     */
    'minScore': number;
    /**
     *
     * @type {string}
     * @memberof RecognitionConfig
     */
    'modelName': string;
    /**
     *
     * @type {ModelType}
     * @memberof RecognitionConfig
     */
    'modelType'?: ModelType;
}


/**
 *
 * @export
 * @interface ScanLibraryDto
 */
export interface ScanLibraryDto {
    /**
     *
     * @type {boolean}
     * @memberof ScanLibraryDto
     */
    'refreshAllFiles'?: boolean;
    /**
     *
     * @type {boolean}
     * @memberof ScanLibraryDto
     */
    'refreshModifiedFiles'?: boolean;
}

/**
 *
 * @export
 * @interface SearchAlbumResponseDto
 */
export interface SearchAlbumResponseDto {
    /**
     *
     * @type {number}
     * @memberof SearchAlbumResponseDto
     */
    'count': number;
    /**
     *
     * @type {Array<SearchFacetResponseDto>}
     * @memberof SearchAlbumResponseDto
     */
    'facets': Array<SearchFacetResponseDto>;
    /**
     *
     * @type {Array<AlbumResponseDto>}
     * @memberof SearchAlbumResponseDto
     */
    'items': Array<AlbumResponseDto>;
    /**
     *
     * @type {number}
     * @memberof SearchAlbumResponseDto
     */
    'total': number;
}

/**
 *
 * @export
 * @interface SearchAssetResponseDto
 */
export interface SearchAssetResponseDto {
    /**
     *
     * @type {number}
     * @memberof SearchAssetResponseDto
     */
    'count': number;
    /**
     *
     * @type {Array<SearchFacetResponseDto>}
     * @memberof SearchAssetResponseDto
     */
    'facets': Array<SearchFacetResponseDto>;
    /**
     *
     * @type {Array<AssetResponseDto>}
     * @memberof SearchAssetResponseDto
     */
    'items': Array<AssetResponseDto>;
    /**
     *
     * @type {number}
     * @memberof SearchAssetResponseDto
     */
    'total': number;
}

/**
 *
 * @export
 * @interface SearchExploreItem
 */
export interface SearchExploreItem {
    /**
     *
     * @type {AssetResponseDto}
     * @memberof SearchExploreItem
     */
    'data': AssetResponseDto;
    /**
     *
     * @type {string}
     * @memberof SearchExploreItem
     */
    'value': string;
}

/**
 *
 * @export
 * @interface SearchExploreResponseDto
 */
export interface SearchExploreResponseDto {
    /**
     *
     * @type {string}
     * @memberof SearchExploreResponseDto
     */
    'fieldName': string;
    /**
     *
     * @type {Array<SearchExploreItem>}
     * @memberof SearchExploreResponseDto
     */
    'items': Array<SearchExploreItem>;
}

/**
 *
 * @export
 * @interface SearchFacetCountResponseDto
 */
export interface SearchFacetCountResponseDto {
    /**
     *
     * @type {number}
     * @memberof SearchFacetCountResponseDto
     */
    'count': number;
    /**
     *
     * @type {string}
     * @memberof SearchFacetCountResponseDto
     */
    'value': string;
}

/**
 *
 * @export
 * @interface SearchFacetResponseDto
 */
export interface SearchFacetResponseDto {
    /**
     *
     * @type {Array<SearchFacetCountResponseDto>}
     * @memberof SearchFacetResponseDto
     */
    'counts': Array<SearchFacetCountResponseDto>;
    /**
     *
     * @type {string}
     * @memberof SearchFacetResponseDto
     */
    'fieldName': string;
}

/**
 *
 * @export
 * @interface SearchResponseDto
 */
export interface SearchResponseDto {
    /**
     *
     * @type {SearchAlbumResponseDto}
     * @memberof SearchResponseDto
     */
    'albums': SearchAlbumResponseDto;
    /**
     *
     * @type {SearchAssetResponseDto}
     * @memberof SearchResponseDto
     */
    'assets': SearchAssetResponseDto;
}

/**
 *
 * @export
 * @interface ServerConfigDto
 */
export interface ServerConfigDto {
    /**
     *
     * @type {boolean}
     * @memberof ServerConfigDto
     */
    'isInitialized': boolean;
    /**
     *
     * @type {string}
     * @memberof ServerConfigDto
     */
    'loginPageMessage': string;
    /**
     *
     * @type {string}
     * @memberof ServerConfigDto
     */
    'oauthButtonText': string;
    /**
     *
     * @type {number}
     * @memberof ServerConfigDto
     */
    'trashDays': number;
}

/**
 *
 * @export
 * @interface ServerFeaturesDto
 */
export interface ServerFeaturesDto {
    /**
     *
     * @type {boolean}
     * @memberof ServerFeaturesDto
     */
    'clipEncode': boolean;
    /**
     *
     * @type {boolean}
     * @memberof ServerFeaturesDto
     */
    'configFile': boolean;
    /**
     *
     * @type {boolean}
     * @memberof ServerFeaturesDto
     */
    'facialRecognition': boolean;
    /**
     *
     * @type {boolean}
     * @memberof ServerFeaturesDto
     */
    'map': boolean;
    /**
     *
     * @type {boolean}
     * @memberof ServerFeaturesDto
     */
    'oauth': boolean;
    /**
     *
     * @type {boolean}
     * @memberof ServerFeaturesDto
     */
    'oauthAutoLaunch': boolean;
    /**
     *
     * @type {boolean}
     * @memberof ServerFeaturesDto
     */
    'passwordLogin': boolean;
    /**
     *
     * @type {boolean}
     * @memberof ServerFeaturesDto
     */
    'reverseGeocoding': boolean;
    /**
     *
     * @type {boolean}
     * @memberof ServerFeaturesDto
     */
    'search': boolean;
    /**
     *
     * @type {boolean}
     * @memberof ServerFeaturesDto
     */
    'sidecar': boolean;
    /**
     *
     * @type {boolean}
     * @memberof ServerFeaturesDto
     */
    'tagImage': boolean;
    /**
     *
     * @type {boolean}
     * @memberof ServerFeaturesDto
     */
    'trash': boolean;
}

/**
 *
 * @export
 * @interface ServerInfoResponseDto
 */
export interface ServerInfoResponseDto {
    /**
     *
     * @type {string}
     * @memberof ServerInfoResponseDto
     */
    'diskAvailable': string;
    /**
     *
     * @type {number}
     * @memberof ServerInfoResponseDto
     */
    'diskAvailableRaw': number;
    /**
     *
     * @type {string}
     * @memberof ServerInfoResponseDto
     */
    'diskSize': string;
    /**
     *
     * @type {number}
     * @memberof ServerInfoResponseDto
     */
    'diskSizeRaw': number;
    /**
     *
     * @type {number}
     * @memberof ServerInfoResponseDto
     */
    'diskUsagePercentage': number;
    /**
     *
     * @type {string}
     * @memberof ServerInfoResponseDto
     */
    'diskUse': string;
    /**
     *
     * @type {number}
     * @memberof ServerInfoResponseDto
     */
    'diskUseRaw': number;
}

/**
 *
 * @export
 * @interface ServerMediaTypesResponseDto
 */
export interface ServerMediaTypesResponseDto {
    /**
     *
     * @type {Array<string>}
     * @memberof ServerMediaTypesResponseDto
     */
    'image': Array<string>;
    /**
     *
     * @type {Array<string>}
     * @memberof ServerMediaTypesResponseDto
     */
    'sidecar': Array<string>;
    /**
     *
     * @type {Array<string>}
     * @memberof ServerMediaTypesResponseDto
     */
    'video': Array<string>;
}

/**
 *
 * @export
 * @interface ServerPingResponse
 */
export interface ServerPingResponse {
    /**
     *
     * @type {string}
     * @memberof ServerPingResponse
     */
    'res': string;
}

/**
 *
 * @export
 * @interface ServerStatsResponseDto
 */
export interface ServerStatsResponseDto {
    /**
     *
     * @type {number}
     * @memberof ServerStatsResponseDto
     */
    'photos': number;
    /**
     *
     * @type {number}
     * @memberof ServerStatsResponseDto
     */
    'usage': number;
    /**
     *
     * @type {Array<UsageByUserDto>}
     * @memberof ServerStatsResponseDto
     */
    'usageByUser': Array<UsageByUserDto>;
    /**
     *
     * @type {number}
     * @memberof ServerStatsResponseDto
     */
    'videos': number;
}

/**
 *
 * @export
 * @interface ServerThemeDto
 */
export interface ServerThemeDto {
    /**
     *
     * @type {string}
     * @memberof ServerThemeDto
     */
    'customCss': string;
}

/**
 *
 * @export
 * @interface ServerVersionResponseDto
 */
export interface ServerVersionResponseDto {
    /**
     *
     * @type {number}
     * @memberof ServerVersionResponseDto
     */
    'major': number;
    /**
     *
     * @type {number}
     * @memberof ServerVersionResponseDto
     */
    'minor': number;
    /**
     *
     * @type {number}
     * @memberof ServerVersionResponseDto
     */
    'patch': number;
}

/**
 *
 * @export
 * @interface SharedLinkCreateDto
 */
export interface SharedLinkCreateDto {
    /**
     *
     * @type {string}
     * @memberof SharedLinkCreateDto
     */
    'albumId'?: string;
    /**
     *
     * @type {boolean}
     * @memberof SharedLinkCreateDto
     */
    'allowDownload'?: boolean;
    /**
     *
     * @type {boolean}
     * @memberof SharedLinkCreateDto
     */
    'allowUpload'?: boolean;
    /**
     *
     * @type {Array<string>}
     * @memberof SharedLinkCreateDto
     */
    'assetIds'?: Array<string>;
    /**
     *
     * @type {string}
     * @memberof SharedLinkCreateDto
     */
    'description'?: string;
    /**
     *
     * @type {string}
     * @memberof SharedLinkCreateDto
     */
    'expiresAt'?: string | null;
    /**
     *
     * @type {string}
     * @memberof SharedLinkCreateDto
     */
    'password'?: string;
    /**
     *
     * @type {boolean}
     * @memberof SharedLinkCreateDto
     */
    'showMetadata'?: boolean;
    /**
     *
     * @type {SharedLinkType}
     * @memberof SharedLinkCreateDto
     */
    'type': SharedLinkType;
}


/**
 *
 * @export
 * @interface SharedLinkEditDto
 */
export interface SharedLinkEditDto {
    /**
     *
     * @type {boolean}
     * @memberof SharedLinkEditDto
     */
    'allowDownload'?: boolean;
    /**
     *
     * @type {boolean}
     * @memberof SharedLinkEditDto
     */
    'allowUpload'?: boolean;
    /**
     * Few clients cannot send null to set the expiryTime to never. Setting this flag and not sending expiryAt is considered as null instead. Clients that can send null values can ignore this.
     * @type {boolean}
     * @memberof SharedLinkEditDto
     */
    'changeExpiryTime'?: boolean;
    /**
     *
     * @type {string}
     * @memberof SharedLinkEditDto
     */
    'description'?: string;
    /**
     *
     * @type {string}
     * @memberof SharedLinkEditDto
     */
    'expiresAt'?: string | null;
    /**
     *
     * @type {string}
     * @memberof SharedLinkEditDto
     */
    'password'?: string;
    /**
     *
     * @type {boolean}
     * @memberof SharedLinkEditDto
     */
    'showMetadata'?: boolean;
}

/**
 *
 * @export
 * @interface SharedLinkResponseDto
 */
export interface SharedLinkResponseDto {
    /**
     *
     * @type {AlbumResponseDto}
     * @memberof SharedLinkResponseDto
     */
    'album'?: AlbumResponseDto;
    /**
     *
     * @type {boolean}
     * @memberof SharedLinkResponseDto
     */
    'allowDownload': boolean;
    /**
     *
     * @type {boolean}
     * @memberof SharedLinkResponseDto
     */
    'allowUpload': boolean;
    /**
     *
     * @type {Array<AssetResponseDto>}
     * @memberof SharedLinkResponseDto
     */
    'assets': Array<AssetResponseDto>;
    /**
     *
     * @type {string}
     * @memberof SharedLinkResponseDto
     */
    'createdAt': string;
    /**
     *
     * @type {string}
     * @memberof SharedLinkResponseDto
     */
    'description': string | null;
    /**
     *
     * @type {string}
     * @memberof SharedLinkResponseDto
     */
    'expiresAt': string | null;
    /**
     *
     * @type {string}
     * @memberof SharedLinkResponseDto
     */
    'id': string;
    /**
     *
     * @type {string}
     * @memberof SharedLinkResponseDto
     */
    'key': string;
    /**
     *
     * @type {string}
     * @memberof SharedLinkResponseDto
     */
    'password': string | null;
    /**
     *
     * @type {boolean}
     * @memberof SharedLinkResponseDto
     */
    'showMetadata': boolean;
    /**
     *
     * @type {string}
     * @memberof SharedLinkResponseDto
     */
    'token'?: string | null;
    /**
     *
     * @type {SharedLinkType}
     * @memberof SharedLinkResponseDto
     */
    'type': SharedLinkType;
    /**
     *
     * @type {string}
     * @memberof SharedLinkResponseDto
     */
    'userId': string;
}


/**
 *
 * @export
 * @enum {string}
 */

export const SharedLinkType = {
    Album: 'ALBUM',
    Individual: 'INDIVIDUAL'
} as const;

export type SharedLinkType = typeof SharedLinkType[keyof typeof SharedLinkType];


/**
 *
 * @export
 * @interface SignUpDto
 */
export interface SignUpDto {
    /**
     *
     * @type {string}
     * @memberof SignUpDto
     */
    'email': string;
    /**
     *
     * @type {string}
     * @memberof SignUpDto
     */
    'name': string;
    /**
     *
     * @type {string}
     * @memberof SignUpDto
     */
    'password': string;
}

/**
 *
 * @export
 * @interface SmartInfoResponseDto
 */
export interface SmartInfoResponseDto {
    /**
     *
     * @type {Array<string>}
     * @memberof SmartInfoResponseDto
     */
    'objects'?: Array<string> | null;
    /**
     *
     * @type {Array<string>}
     * @memberof SmartInfoResponseDto
     */
    'tags'?: Array<string> | null;
}

/**
 *
 * @export
 * @interface SystemConfigDto
 */
export interface SystemConfigDto {
    /**
     *
     * @type {SystemConfigFFmpegDto}
     * @memberof SystemConfigDto
     */
    'ffmpeg': SystemConfigFFmpegDto;
    /**
     *
     * @type {SystemConfigJobDto}
     * @memberof SystemConfigDto
     */
    'job': SystemConfigJobDto;
    /**
     *
     * @type {SystemConfigLibraryDto}
     * @memberof SystemConfigDto
     */
    'library': SystemConfigLibraryDto;
    /**
     *
     * @type {SystemConfigLoggingDto}
     * @memberof SystemConfigDto
     */
    'logging': SystemConfigLoggingDto;
    /**
     *
     * @type {SystemConfigMachineLearningDto}
     * @memberof SystemConfigDto
     */
    'machineLearning': SystemConfigMachineLearningDto;
    /**
     *
     * @type {SystemConfigMapDto}
     * @memberof SystemConfigDto
     */
    'map': SystemConfigMapDto;
    /**
     *
     * @type {SystemConfigNewVersionCheckDto}
     * @memberof SystemConfigDto
     */
    'newVersionCheck': SystemConfigNewVersionCheckDto;
    /**
     *
     * @type {SystemConfigOAuthDto}
     * @memberof SystemConfigDto
     */
    'oauth': SystemConfigOAuthDto;
    /**
     *
     * @type {SystemConfigPasswordLoginDto}
     * @memberof SystemConfigDto
     */
    'passwordLogin': SystemConfigPasswordLoginDto;
    /**
     *
     * @type {SystemConfigReverseGeocodingDto}
     * @memberof SystemConfigDto
     */
    'reverseGeocoding': SystemConfigReverseGeocodingDto;
    /**
     *
     * @type {SystemConfigStorageTemplateDto}
     * @memberof SystemConfigDto
     */
    'storageTemplate': SystemConfigStorageTemplateDto;
    /**
     *
     * @type {SystemConfigThemeDto}
     * @memberof SystemConfigDto
     */
    'theme': SystemConfigThemeDto;
    /**
     *
     * @type {SystemConfigThumbnailDto}
     * @memberof SystemConfigDto
     */
    'thumbnail': SystemConfigThumbnailDto;
    /**
     *
     * @type {SystemConfigTrashDto}
     * @memberof SystemConfigDto
     */
    'trash': SystemConfigTrashDto;
}

/**
 *
 * @export
 * @interface SystemConfigFFmpegDto
 */
export interface SystemConfigFFmpegDto {
    /**
     *
     * @type {TranscodeHWAccel}
     * @memberof SystemConfigFFmpegDto
     */
    'accel': TranscodeHWAccel;
    /**
     *
     * @type {number}
     * @memberof SystemConfigFFmpegDto
     */
    'bframes': number;
    /**
     *
     * @type {CQMode}
     * @memberof SystemConfigFFmpegDto
     */
    'cqMode': CQMode;
    /**
     *
     * @type {number}
     * @memberof SystemConfigFFmpegDto
     */
    'crf': number;
    /**
     *
     * @type {number}
     * @memberof SystemConfigFFmpegDto
     */
    'gopSize': number;
    /**
     *
     * @type {string}
     * @memberof SystemConfigFFmpegDto
     */
    'maxBitrate': string;
    /**
     *
     * @type {number}
     * @memberof SystemConfigFFmpegDto
     */
    'npl': number;
    /**
     *
     * @type {string}
     * @memberof SystemConfigFFmpegDto
     */
    'preset': string;
    /**
     *
     * @type {number}
     * @memberof SystemConfigFFmpegDto
     */
    'refs': number;
    /**
     *
     * @type {AudioCodec}
     * @memberof SystemConfigFFmpegDto
     */
    'targetAudioCodec': AudioCodec;
    /**
     *
     * @type {string}
     * @memberof SystemConfigFFmpegDto
     */
    'targetResolution': string;
    /**
     *
     * @type {VideoCodec}
     * @memberof SystemConfigFFmpegDto
     */
    'targetVideoCodec': VideoCodec;
    /**
     *
     * @type {boolean}
     * @memberof SystemConfigFFmpegDto
     */
    'temporalAQ': boolean;
    /**
     *
     * @type {number}
     * @memberof SystemConfigFFmpegDto
     */
    'threads': number;
    /**
     *
     * @type {ToneMapping}
     * @memberof SystemConfigFFmpegDto
     */
    'tonemap': ToneMapping;
    /**
     *
     * @type {TranscodePolicy}
     * @memberof SystemConfigFFmpegDto
     */
    'transcode': TranscodePolicy;
    /**
     *
     * @type {boolean}
     * @memberof SystemConfigFFmpegDto
     */
    'twoPass': boolean;
}


/**
 *
 * @export
 * @interface SystemConfigJobDto
 */
export interface SystemConfigJobDto {
    /**
     *
     * @type {JobSettingsDto}
     * @memberof SystemConfigJobDto
     */
    'backgroundTask': JobSettingsDto;
    /**
     *
     * @type {JobSettingsDto}
     * @memberof SystemConfigJobDto
     */
    'library': JobSettingsDto;
    /**
     *
     * @type {JobSettingsDto}
     * @memberof SystemConfigJobDto
     */
    'metadataExtraction': JobSettingsDto;
    /**
     *
     * @type {JobSettingsDto}
     * @memberof SystemConfigJobDto
     */
    'migration': JobSettingsDto;
    /**
     *
     * @type {JobSettingsDto}
     * @memberof SystemConfigJobDto
     */
    'objectTagging': JobSettingsDto;
    /**
     *
     * @type {JobSettingsDto}
     * @memberof SystemConfigJobDto
     */
    'recognizeFaces': JobSettingsDto;
    /**
     *
     * @type {JobSettingsDto}
     * @memberof SystemConfigJobDto
     */
    'search': JobSettingsDto;
    /**
     *
     * @type {JobSettingsDto}
     * @memberof SystemConfigJobDto
     */
    'sidecar': JobSettingsDto;
    /**
     *
     * @type {JobSettingsDto}
     * @memberof SystemConfigJobDto
     */
    'smartSearch': JobSettingsDto;
    /**
     *
     * @type {JobSettingsDto}
     * @memberof SystemConfigJobDto
     */
    'storageTemplateMigration': JobSettingsDto;
    /**
     *
     * @type {JobSettingsDto}
     * @memberof SystemConfigJobDto
     */
    'thumbnailGeneration': JobSettingsDto;
    /**
     *
     * @type {JobSettingsDto}
     * @memberof SystemConfigJobDto
     */
    'videoConversion': JobSettingsDto;
}

/**
 *
 * @export
 * @interface SystemConfigLibraryDto
 */
export interface SystemConfigLibraryDto {
    /**
     *
     * @type {SystemConfigLibraryScanDto}
     * @memberof SystemConfigLibraryDto
     */
    'scan': SystemConfigLibraryScanDto;
}

/**
 *
 * @export
 * @interface SystemConfigLibraryScanDto
 */
export interface SystemConfigLibraryScanDto {
    /**
     *
     * @type {string}
     * @memberof SystemConfigLibraryScanDto
     */
    'cronExpression': string;
    /**
     *
     * @type {boolean}
     * @memberof SystemConfigLibraryScanDto
     */
    'enabled': boolean;
}

/**
 *
 * @export
 * @interface SystemConfigLoggingDto
 */
export interface SystemConfigLoggingDto {
    /**
     *
     * @type {boolean}
     * @memberof SystemConfigLoggingDto
     */
    'enabled': boolean;
    /**
     *
     * @type {LogLevel}
     * @memberof SystemConfigLoggingDto
     */
    'level': LogLevel;
}


/**
 *
 * @export
 * @interface SystemConfigMachineLearningDto
 */
export interface SystemConfigMachineLearningDto {
    /**
     *
     * @type {ClassificationConfig}
     * @memberof SystemConfigMachineLearningDto
     */
    'classification': ClassificationConfig;
    /**
     *
     * @type {CLIPConfig}
     * @memberof SystemConfigMachineLearningDto
     */
    'clip': CLIPConfig;
    /**
     *
     * @type {boolean}
     * @memberof SystemConfigMachineLearningDto
     */
    'enabled': boolean;
    /**
     *
     * @type {RecognitionConfig}
     * @memberof SystemConfigMachineLearningDto
     */
    'facialRecognition': RecognitionConfig;
    /**
     *
     * @type {string}
     * @memberof SystemConfigMachineLearningDto
     */
    'url': string;
}

/**
 *
 * @export
 * @interface SystemConfigMapDto
 */
export interface SystemConfigMapDto {
    /**
     *
     * @type {string}
     * @memberof SystemConfigMapDto
     */
    'darkStyle': string;
    /**
     *
     * @type {boolean}
     * @memberof SystemConfigMapDto
     */
    'enabled': boolean;
    /**
     *
     * @type {string}
     * @memberof SystemConfigMapDto
     */
    'lightStyle': string;
}

/**
 *
 * @export
 * @interface SystemConfigNewVersionCheckDto
 */
export interface SystemConfigNewVersionCheckDto {
    /**
     *
     * @type {boolean}
     * @memberof SystemConfigNewVersionCheckDto
     */
    'enabled': boolean;
}

/**
 *
 * @export
 * @interface SystemConfigOAuthDto
 */
export interface SystemConfigOAuthDto {
    /**
     *
     * @type {boolean}
     * @memberof SystemConfigOAuthDto
     */
    'autoLaunch': boolean;
    /**
     *
     * @type {boolean}
     * @memberof SystemConfigOAuthDto
     */
    'autoRegister': boolean;
    /**
     *
     * @type {string}
     * @memberof SystemConfigOAuthDto
     */
    'buttonText': string;
    /**
     *
     * @type {string}
     * @memberof SystemConfigOAuthDto
     */
    'clientId': string;
    /**
     *
     * @type {string}
     * @memberof SystemConfigOAuthDto
     */
    'clientSecret': string;
    /**
     *
     * @type {boolean}
     * @memberof SystemConfigOAuthDto
     */
    'enabled': boolean;
    /**
     *
     * @type {string}
     * @memberof SystemConfigOAuthDto
     */
    'issuerUrl': string;
    /**
     *
     * @type {boolean}
     * @memberof SystemConfigOAuthDto
     */
    'mobileOverrideEnabled': boolean;
    /**
     *
     * @type {string}
     * @memberof SystemConfigOAuthDto
     */
    'mobileRedirectUri': string;
    /**
     *
     * @type {string}
     * @memberof SystemConfigOAuthDto
     */
    'scope': string;
    /**
     *
     * @type {string}
     * @memberof SystemConfigOAuthDto
     */
    'storageLabelClaim': string;
}

/**
 *
 * @export
 * @interface SystemConfigPasswordLoginDto
 */
export interface SystemConfigPasswordLoginDto {
    /**
     *
     * @type {boolean}
     * @memberof SystemConfigPasswordLoginDto
     */
    'enabled': boolean;
}

/**
 *
 * @export
 * @interface SystemConfigReverseGeocodingDto
 */
export interface SystemConfigReverseGeocodingDto {
    /**
     *
     * @type {boolean}
     * @memberof SystemConfigReverseGeocodingDto
     */
    'enabled': boolean;
}

/**
 *
 * @export
 * @interface SystemConfigStorageTemplateDto
 */
export interface SystemConfigStorageTemplateDto {
    /**
     *
     * @type {string}
     * @memberof SystemConfigStorageTemplateDto
     */
    'template': string;
}

/**
 *
 * @export
 * @interface SystemConfigTemplateStorageOptionDto
 */
export interface SystemConfigTemplateStorageOptionDto {
    /**
     *
     * @type {Array<string>}
     * @memberof SystemConfigTemplateStorageOptionDto
     */
    'dayOptions': Array<string>;
    /**
     *
     * @type {Array<string>}
     * @memberof SystemConfigTemplateStorageOptionDto
     */
    'hourOptions': Array<string>;
    /**
     *
     * @type {Array<string>}
     * @memberof SystemConfigTemplateStorageOptionDto
     */
    'minuteOptions': Array<string>;
    /**
     *
     * @type {Array<string>}
     * @memberof SystemConfigTemplateStorageOptionDto
     */
    'monthOptions': Array<string>;
    /**
     *
     * @type {Array<string>}
     * @memberof SystemConfigTemplateStorageOptionDto
     */
    'presetOptions': Array<string>;
    /**
     *
     * @type {Array<string>}
     * @memberof SystemConfigTemplateStorageOptionDto
     */
    'secondOptions': Array<string>;
    /**
     *
     * @type {Array<string>}
     * @memberof SystemConfigTemplateStorageOptionDto
     */
    'weekOptions': Array<string>;
    /**
     *
     * @type {Array<string>}
     * @memberof SystemConfigTemplateStorageOptionDto
     */
    'yearOptions': Array<string>;
}

/**
 *
 * @export
 * @interface SystemConfigThemeDto
 */
export interface SystemConfigThemeDto {
    /**
     *
     * @type {string}
     * @memberof SystemConfigThemeDto
     */
    'customCss': string;
}

/**
 *
 * @export
 * @interface SystemConfigThumbnailDto
 */
export interface SystemConfigThumbnailDto {
    /**
     *
     * @type {Colorspace}
     * @memberof SystemConfigThumbnailDto
     */
    'colorspace': Colorspace;
    /**
     *
     * @type {number}
     * @memberof SystemConfigThumbnailDto
     */
    'jpegSize': number;
    /**
     *
     * @type {number}
     * @memberof SystemConfigThumbnailDto
     */
    'quality': number;
    /**
     *
     * @type {number}
     * @memberof SystemConfigThumbnailDto
     */
    'webpSize': number;
}


/**
 *
 * @export
 * @interface SystemConfigTrashDto
 */
export interface SystemConfigTrashDto {
    /**
     *
     * @type {number}
     * @memberof SystemConfigTrashDto
     */
    'days': number;
    /**
     *
     * @type {boolean}
     * @memberof SystemConfigTrashDto
     */
    'enabled': boolean;
}

/**
 *
 * @export
 * @interface TagResponseDto
 */
export interface TagResponseDto {
    /**
     *
     * @type {string}
     * @memberof TagResponseDto
     */
    'id': string;
    /**
     *
     * @type {string}
     * @memberof TagResponseDto
     */
    'name': string;
    /**
     *
     * @type {TagTypeEnum}
     * @memberof TagResponseDto
     */
    'type': TagTypeEnum;
    /**
     *
     * @type {string}
     * @memberof TagResponseDto
     */
    'userId': string;
}


/**
 *
 * @export
 * @enum {string}
 */

export const TagTypeEnum = {
    Object: 'OBJECT',
    Face: 'FACE',
    Custom: 'CUSTOM'
} as const;

export type TagTypeEnum = typeof TagTypeEnum[keyof typeof TagTypeEnum];


/**
 *
 * @export
 * @enum {string}
 */

export const ThumbnailFormat = {
    Jpeg: 'JPEG',
    Webp: 'WEBP'
} as const;

export type ThumbnailFormat = typeof ThumbnailFormat[keyof typeof ThumbnailFormat];


/**
 *
 * @export
 * @interface TimeBucketResponseDto
 */
export interface TimeBucketResponseDto {
    /**
     *
     * @type {number}
     * @memberof TimeBucketResponseDto
     */
    'count': number;
    /**
     *
     * @type {string}
     * @memberof TimeBucketResponseDto
     */
    'timeBucket': string;
}

/**
 *
 * @export
 * @enum {string}
 */

export const TimeBucketSize = {
    Day: 'DAY',
    Month: 'MONTH'
} as const;

export type TimeBucketSize = typeof TimeBucketSize[keyof typeof TimeBucketSize];


/**
 *
 * @export
 * @enum {string}
 */

export const ToneMapping = {
    Hable: 'hable',
    Mobius: 'mobius',
    Reinhard: 'reinhard',
    Disabled: 'disabled'
} as const;

export type ToneMapping = typeof ToneMapping[keyof typeof ToneMapping];


/**
 *
 * @export
 * @enum {string}
 */

export const TranscodeHWAccel = {
    Nvenc: 'nvenc',
    Qsv: 'qsv',
    Vaapi: 'vaapi',
    Rkmpp: 'rkmpp',
    Disabled: 'disabled'
} as const;

export type TranscodeHWAccel = typeof TranscodeHWAccel[keyof typeof TranscodeHWAccel];


/**
 *
 * @export
 * @enum {string}
 */

export const TranscodePolicy = {
    All: 'all',
    Optimal: 'optimal',
    Required: 'required',
    Disabled: 'disabled'
} as const;

export type TranscodePolicy = typeof TranscodePolicy[keyof typeof TranscodePolicy];


/**
 *
 * @export
 * @interface UpdateAlbumDto
 */
export interface UpdateAlbumDto {
    /**
     *
     * @type {string}
     * @memberof UpdateAlbumDto
     */
    'albumName'?: string;
    /**
     *
     * @type {string}
     * @memberof UpdateAlbumDto
     */
    'albumThumbnailAssetId'?: string;
    /**
     *
     * @type {string}
     * @memberof UpdateAlbumDto
     */
    'description'?: string;
    /**
     *
     * @type {boolean}
     * @memberof UpdateAlbumDto
     */
    'isActivityEnabled'?: boolean;
}

/**
 *
 * @export
 * @interface UpdateAssetDto
 */
export interface UpdateAssetDto {
    /**
     *
     * @type {string}
     * @memberof UpdateAssetDto
     */
    'dateTimeOriginal'?: string;
    /**
     *
     * @type {string}
     * @memberof UpdateAssetDto
     */
    'description'?: string;
    /**
     *
     * @type {boolean}
     * @memberof UpdateAssetDto
     */
    'isArchived'?: boolean;
    /**
     *
     * @type {boolean}
     * @memberof UpdateAssetDto
     */
    'isFavorite'?: boolean;
    /**
     *
     * @type {number}
     * @memberof UpdateAssetDto
     */
    'latitude'?: number;
    /**
     *
     * @type {number}
     * @memberof UpdateAssetDto
     */
    'longitude'?: number;
}

/**
 *
 * @export
 * @interface UpdateLibraryDto
 */
export interface UpdateLibraryDto {
    /**
     *
     * @type {Array<string>}
     * @memberof UpdateLibraryDto
     */
    'exclusionPatterns'?: Array<string>;
    /**
     *
     * @type {Array<string>}
     * @memberof UpdateLibraryDto
     */
    'importPaths'?: Array<string>;
    /**
     *
     * @type {boolean}
     * @memberof UpdateLibraryDto
     */
    'isVisible'?: boolean;
    /**
     *
     * @type {string}
     * @memberof UpdateLibraryDto
     */
    'name'?: string;
}

/**
 *
 * @export
 * @interface UpdatePartnerDto
 */
export interface UpdatePartnerDto {
    /**
     *
     * @type {boolean}
     * @memberof UpdatePartnerDto
     */
    'inTimeline': boolean;
}

/**
 *
 * @export
 * @interface UpdateStackParentDto
 */
export interface UpdateStackParentDto {
    /**
     *
     * @type {string}
     * @memberof UpdateStackParentDto
     */
    'newParentId': string;
    /**
     *
     * @type {string}
     * @memberof UpdateStackParentDto
     */
    'oldParentId': string;
}

/**
 *
 * @export
 * @interface UpdateTagDto
 */
export interface UpdateTagDto {
    /**
     *
     * @type {string}
     * @memberof UpdateTagDto
     */
    'name'?: string;
}

/**
 *
 * @export
 * @interface UpdateUserDto
 */
export interface UpdateUserDto {
    /**
     *
     * @type {UserAvatarColor}
     * @memberof UpdateUserDto
     */
    'avatarColor'?: UserAvatarColor;
    /**
     *
     * @type {string}
     * @memberof UpdateUserDto
     */
    'email'?: string;
    /**
     *
     * @type {string}
     * @memberof UpdateUserDto
     */
    'externalPath'?: string;
    /**
     *
     * @type {string}
     * @memberof UpdateUserDto
     */
    'id': string;
    /**
     *
     * @type {boolean}
     * @memberof UpdateUserDto
     */
    'isAdmin'?: boolean;
    /**
     *
     * @type {boolean}
     * @memberof UpdateUserDto
     */
    'memoriesEnabled'?: boolean;
    /**
     *
     * @type {string}
     * @memberof UpdateUserDto
     */
    'name'?: string;
    /**
     *
     * @type {string}
     * @memberof UpdateUserDto
     */
    'password'?: string;
    /**
     *
     * @type {boolean}
     * @memberof UpdateUserDto
     */
    'shouldChangePassword'?: boolean;
    /**
     *
     * @type {string}
     * @memberof UpdateUserDto
     */
    'storageLabel'?: string;
}


/**
 *
 * @export
 * @interface UsageByUserDto
 */
export interface UsageByUserDto {
    /**
     *
     * @type {number}
     * @memberof UsageByUserDto
     */
    'photos': number;
    /**
     *
     * @type {number}
     * @memberof UsageByUserDto
     */
    'usage': number;
    /**
     *
     * @type {string}
     * @memberof UsageByUserDto
     */
    'userId': string;
    /**
     *
     * @type {string}
     * @memberof UsageByUserDto
     */
    'userName': string;
    /**
     *
     * @type {number}
     * @memberof UsageByUserDto
     */
    'videos': number;
}

/**
 *
 * @export
 * @enum {string}
 */

export const UserAvatarColor = {
    Primary: 'primary',
    Pink: 'pink',
    Red: 'red',
    Yellow: 'yellow',
    Blue: 'blue',
    Green: 'green',
    Purple: 'purple',
    Orange: 'orange',
    Gray: 'gray',
    Amber: 'amber'
} as const;

export type UserAvatarColor = typeof UserAvatarColor[keyof typeof UserAvatarColor];


/**
 *
 * @export
 * @interface UserDto
 */
export interface UserDto {
    /**
     *
     * @type {UserAvatarColor}
     * @memberof UserDto
     */
    'avatarColor': UserAvatarColor;
    /**
     *
     * @type {string}
     * @memberof UserDto
     */
    'email': string;
    /**
     *
     * @type {string}
     * @memberof UserDto
     */
    'id': string;
    /**
     *
     * @type {string}
     * @memberof UserDto
     */
    'name': string;
    /**
     *
     * @type {string}
     * @memberof UserDto
     */
    'profileImagePath': string;
}


/**
 *
 * @export
 * @interface UserResponseDto
 */
export interface UserResponseDto {
    /**
     *
     * @type {UserAvatarColor}
     * @memberof UserResponseDto
     */
    'avatarColor': UserAvatarColor;
    /**
     *
     * @type {string}
     * @memberof UserResponseDto
     */
    'createdAt': string;
    /**
     *
     * @type {string}
     * @memberof UserResponseDto
     */
    'deletedAt': string | null;
    /**
     *
     * @type {string}
     * @memberof UserResponseDto
     */
    'email': string;
    /**
     *
     * @type {string}
     * @memberof UserResponseDto
     */
    'externalPath': string | null;
    /**
     *
     * @type {string}
     * @memberof UserResponseDto
     */
    'id': string;
    /**
     *
     * @type {boolean}
     * @memberof UserResponseDto
     */
    'isAdmin': boolean;
    /**
     *
     * @type {boolean}
     * @memberof UserResponseDto
     */
    'memoriesEnabled'?: boolean;
    /**
     *
     * @type {string}
     * @memberof UserResponseDto
     */
    'name': string;
    /**
     *
     * @type {string}
     * @memberof UserResponseDto
     */
    'oauthId': string;
    /**
     *
     * @type {string}
     * @memberof UserResponseDto
     */
    'profileImagePath': string;
    /**
     *
     * @type {boolean}
     * @memberof UserResponseDto
     */
    'shouldChangePassword': boolean;
    /**
     *
     * @type {string}
     * @memberof UserResponseDto
     */
    'storageLabel': string | null;
    /**
     *
     * @type {string}
     * @memberof UserResponseDto
     */
    'updatedAt': string;
}


/**
 *
 * @export
 * @interface ValidateAccessTokenResponseDto
 */
export interface ValidateAccessTokenResponseDto {
    /**
     *
     * @type {boolean}
     * @memberof ValidateAccessTokenResponseDto
     */
    'authStatus': boolean;
}

/**
 *
 * @export
 * @enum {string}
 */

export const VideoCodec = {
    H264: 'h264',
    Hevc: 'hevc',
    Vp9: 'vp9'
} as const;

export type VideoCodec = typeof VideoCodec[keyof typeof VideoCodec];


/**
 * APIKeyApi - axios parameter creator
 * @export
 */
export const APIKeyApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *
         * @param {APIKeyCreateDto} aPIKeyCreateDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createApiKey: async (aPIKeyCreateDto: APIKeyCreateDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'aPIKeyCreateDto' is not null or undefined
            assertParamExists('createApiKey', 'aPIKeyCreateDto', aPIKeyCreateDto)
            const localVarPath = `/api-key`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookie required

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(aPIKeyCreateDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteApiKey: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteApiKey', 'id', id)
            const localVarPath = `/api-key/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookie required

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApiKey: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getApiKey', 'id', id)
            const localVarPath = `/api-key/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookie required

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApiKeys: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api-key`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookie required

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {string} id
         * @param {APIKeyUpdateDto} aPIKeyUpdateDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateApiKey: async (id: string, aPIKeyUpdateDto: APIKeyUpdateDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateApiKey', 'id', id)
            // verify required parameter 'aPIKeyUpdateDto' is not null or undefined
            assertParamExists('updateApiKey', 'aPIKeyUpdateDto', aPIKeyUpdateDto)
            const localVarPath = `/api-key/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookie required

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(aPIKeyUpdateDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * APIKeyApi - functional programming interface
 * @export
 */
export const APIKeyApiFp = function (configuration?: Configuration) {
    const localVarAxiosParamCreator = APIKeyApiAxiosParamCreator(configuration)
    return {
        /**
         *
         * @param {APIKeyCreateDto} aPIKeyCreateDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createApiKey(aPIKeyCreateDto: APIKeyCreateDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<APIKeyCreateResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createApiKey(aPIKeyCreateDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteApiKey(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteApiKey(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getApiKey(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<APIKeyResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getApiKey(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getApiKeys(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<APIKeyResponseDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getApiKeys(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {string} id
         * @param {APIKeyUpdateDto} aPIKeyUpdateDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateApiKey(id: string, aPIKeyUpdateDto: APIKeyUpdateDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<APIKeyResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateApiKey(id, aPIKeyUpdateDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * APIKeyApi - factory interface
 * @export
 */
export const APIKeyApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = APIKeyApiFp(configuration)
    return {
        /**
         *
         * @param {APIKeyApiCreateApiKeyRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createApiKey(requestParameters: APIKeyApiCreateApiKeyRequest, options?: AxiosRequestConfig): AxiosPromise<APIKeyCreateResponseDto> {
            return localVarFp.createApiKey(requestParameters.aPIKeyCreateDto, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {APIKeyApiDeleteApiKeyRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteApiKey(requestParameters: APIKeyApiDeleteApiKeyRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteApiKey(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {APIKeyApiGetApiKeyRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApiKey(requestParameters: APIKeyApiGetApiKeyRequest, options?: AxiosRequestConfig): AxiosPromise<APIKeyResponseDto> {
            return localVarFp.getApiKey(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApiKeys(options?: AxiosRequestConfig): AxiosPromise<Array<APIKeyResponseDto>> {
            return localVarFp.getApiKeys(options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {APIKeyApiUpdateApiKeyRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateApiKey(requestParameters: APIKeyApiUpdateApiKeyRequest, options?: AxiosRequestConfig): AxiosPromise<APIKeyResponseDto> {
            return localVarFp.updateApiKey(requestParameters.id, requestParameters.aPIKeyUpdateDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createApiKey operation in APIKeyApi.
 * @export
 * @interface APIKeyApiCreateApiKeyRequest
 */
export interface APIKeyApiCreateApiKeyRequest {
    /**
     *
     * @type {APIKeyCreateDto}
     * @memberof APIKeyApiCreateApiKey
     */
    readonly aPIKeyCreateDto: APIKeyCreateDto
}

/**
 * Request parameters for deleteApiKey operation in APIKeyApi.
 * @export
 * @interface APIKeyApiDeleteApiKeyRequest
 */
export interface APIKeyApiDeleteApiKeyRequest {
    /**
     *
     * @type {string}
     * @memberof APIKeyApiDeleteApiKey
     */
    readonly id: string
}

/**
 * Request parameters for getApiKey operation in APIKeyApi.
 * @export
 * @interface APIKeyApiGetApiKeyRequest
 */
export interface APIKeyApiGetApiKeyRequest {
    /**
     *
     * @type {string}
     * @memberof APIKeyApiGetApiKey
     */
    readonly id: string
}

/**
 * Request parameters for updateApiKey operation in APIKeyApi.
 * @export
 * @interface APIKeyApiUpdateApiKeyRequest
 */
export interface APIKeyApiUpdateApiKeyRequest {
    /**
     *
     * @type {string}
     * @memberof APIKeyApiUpdateApiKey
     */
    readonly id: string

    /**
     *
     * @type {APIKeyUpdateDto}
     * @memberof APIKeyApiUpdateApiKey
     */
    readonly aPIKeyUpdateDto: APIKeyUpdateDto
}

/**
 * APIKeyApi - object-oriented interface
 * @export
 * @class APIKeyApi
 * @extends {BaseAPI}
 */
export class APIKeyApi extends BaseAPI {
    /**
     *
     * @param {APIKeyApiCreateApiKeyRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof APIKeyApi
     */
    public createApiKey(requestParameters: APIKeyApiCreateApiKeyRequest, options?: AxiosRequestConfig) {
        return APIKeyApiFp(this.configuration).createApiKey(requestParameters.aPIKeyCreateDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {APIKeyApiDeleteApiKeyRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof APIKeyApi
     */
    public deleteApiKey(requestParameters: APIKeyApiDeleteApiKeyRequest, options?: AxiosRequestConfig) {
        return APIKeyApiFp(this.configuration).deleteApiKey(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {APIKeyApiGetApiKeyRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof APIKeyApi
     */
    public getApiKey(requestParameters: APIKeyApiGetApiKeyRequest, options?: AxiosRequestConfig) {
        return APIKeyApiFp(this.configuration).getApiKey(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof APIKeyApi
     */
    public getApiKeys(options?: AxiosRequestConfig) {
        return APIKeyApiFp(this.configuration).getApiKeys(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {APIKeyApiUpdateApiKeyRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof APIKeyApi
     */
    public updateApiKey(requestParameters: APIKeyApiUpdateApiKeyRequest, options?: AxiosRequestConfig) {
        return APIKeyApiFp(this.configuration).updateApiKey(requestParameters.id, requestParameters.aPIKeyUpdateDto, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ActivityApi - axios parameter creator
 * @export
 */
export const ActivityApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *
         * @param {ActivityCreateDto} activityCreateDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createActivity: async (activityCreateDto: ActivityCreateDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'activityCreateDto' is not null or undefined
            assertParamExists('createActivity', 'activityCreateDto', activityCreateDto)
            const localVarPath = `/activity`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookie required

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(activityCreateDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteActivity: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteActivity', 'id', id)
            const localVarPath = `/activity/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookie required

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {string} albumId
         * @param {string} [assetId]
         * @param {ReactionType} [type]
         * @param {ReactionLevel} [level]
         * @param {string} [userId]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getActivities: async (albumId: string, assetId?: string, type?: ReactionType, level?: ReactionLevel, userId?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'albumId' is not null or undefined
            assertParamExists('getActivities', 'albumId', albumId)
            const localVarPath = `/activity`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookie required

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (albumId !== undefined) {
                localVarQueryParameter['albumId'] = albumId;
            }

            if (assetId !== undefined) {
                localVarQueryParameter['assetId'] = assetId;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (level !== undefined) {
                localVarQueryParameter['level'] = level;
            }

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }


            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {string} albumId
         * @param {string} [assetId]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getActivityStatistics: async (albumId: string, assetId?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'albumId' is not null or undefined
            assertParamExists('getActivityStatistics', 'albumId', albumId)
            const localVarPath = `/activity/statistics`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookie required

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (albumId !== undefined) {
                localVarQueryParameter['albumId'] = albumId;
            }

            if (assetId !== undefined) {
                localVarQueryParameter['assetId'] = assetId;
            }


            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ActivityApi - functional programming interface
 * @export
 */
export const ActivityApiFp = function (configuration?: Configuration) {
    const localVarAxiosParamCreator = ActivityApiAxiosParamCreator(configuration)
    return {
        /**
         *
         * @param {ActivityCreateDto} activityCreateDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createActivity(activityCreateDto: ActivityCreateDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ActivityResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createActivity(activityCreateDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteActivity(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteActivity(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {string} albumId
         * @param {string} [assetId]
         * @param {ReactionType} [type]
         * @param {ReactionLevel} [level]
         * @param {string} [userId]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getActivities(albumId: string, assetId?: string, type?: ReactionType, level?: ReactionLevel, userId?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ActivityResponseDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getActivities(albumId, assetId, type, level, userId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {string} albumId
         * @param {string} [assetId]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getActivityStatistics(albumId: string, assetId?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ActivityStatisticsResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getActivityStatistics(albumId, assetId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ActivityApi - factory interface
 * @export
 */
export const ActivityApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ActivityApiFp(configuration)
    return {
        /**
         *
         * @param {ActivityApiCreateActivityRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createActivity(requestParameters: ActivityApiCreateActivityRequest, options?: AxiosRequestConfig): AxiosPromise<ActivityResponseDto> {
            return localVarFp.createActivity(requestParameters.activityCreateDto, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {ActivityApiDeleteActivityRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteActivity(requestParameters: ActivityApiDeleteActivityRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteActivity(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {ActivityApiGetActivitiesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getActivities(requestParameters: ActivityApiGetActivitiesRequest, options?: AxiosRequestConfig): AxiosPromise<Array<ActivityResponseDto>> {
            return localVarFp.getActivities(requestParameters.albumId, requestParameters.assetId, requestParameters.type, requestParameters.level, requestParameters.userId, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {ActivityApiGetActivityStatisticsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getActivityStatistics(requestParameters: ActivityApiGetActivityStatisticsRequest, options?: AxiosRequestConfig): AxiosPromise<ActivityStatisticsResponseDto> {
            return localVarFp.getActivityStatistics(requestParameters.albumId, requestParameters.assetId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createActivity operation in ActivityApi.
 * @export
 * @interface ActivityApiCreateActivityRequest
 */
export interface ActivityApiCreateActivityRequest {
    /**
     *
     * @type {ActivityCreateDto}
     * @memberof ActivityApiCreateActivity
     */
    readonly activityCreateDto: ActivityCreateDto
}

/**
 * Request parameters for deleteActivity operation in ActivityApi.
 * @export
 * @interface ActivityApiDeleteActivityRequest
 */
export interface ActivityApiDeleteActivityRequest {
    /**
     *
     * @type {string}
     * @memberof ActivityApiDeleteActivity
     */
    readonly id: string
}

/**
 * Request parameters for getActivities operation in ActivityApi.
 * @export
 * @interface ActivityApiGetActivitiesRequest
 */
export interface ActivityApiGetActivitiesRequest {
    /**
     *
     * @type {string}
     * @memberof ActivityApiGetActivities
     */
    readonly albumId: string

    /**
     *
     * @type {string}
     * @memberof ActivityApiGetActivities
     */
    readonly assetId?: string

    /**
     *
     * @type {ReactionType}
     * @memberof ActivityApiGetActivities
     */
    readonly type?: ReactionType

    /**
     *
     * @type {ReactionLevel}
     * @memberof ActivityApiGetActivities
     */
    readonly level?: ReactionLevel

    /**
     *
     * @type {string}
     * @memberof ActivityApiGetActivities
     */
    readonly userId?: string
}

/**
 * Request parameters for getActivityStatistics operation in ActivityApi.
 * @export
 * @interface ActivityApiGetActivityStatisticsRequest
 */
export interface ActivityApiGetActivityStatisticsRequest {
    /**
     *
     * @type {string}
     * @memberof ActivityApiGetActivityStatistics
     */
    readonly albumId: string

    /**
     *
     * @type {string}
     * @memberof ActivityApiGetActivityStatistics
     */
    readonly assetId?: string
}

/**
 * ActivityApi - object-oriented interface
 * @export
 * @class ActivityApi
 * @extends {BaseAPI}
 */
export class ActivityApi extends BaseAPI {
    /**
     *
     * @param {ActivityApiCreateActivityRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActivityApi
     */
    public createActivity(requestParameters: ActivityApiCreateActivityRequest, options?: AxiosRequestConfig) {
        return ActivityApiFp(this.configuration).createActivity(requestParameters.activityCreateDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {ActivityApiDeleteActivityRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActivityApi
     */
    public deleteActivity(requestParameters: ActivityApiDeleteActivityRequest, options?: AxiosRequestConfig) {
        return ActivityApiFp(this.configuration).deleteActivity(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {ActivityApiGetActivitiesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActivityApi
     */
    public getActivities(requestParameters: ActivityApiGetActivitiesRequest, options?: AxiosRequestConfig) {
        return ActivityApiFp(this.configuration).getActivities(requestParameters.albumId, requestParameters.assetId, requestParameters.type, requestParameters.level, requestParameters.userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {ActivityApiGetActivityStatisticsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActivityApi
     */
    public getActivityStatistics(requestParameters: ActivityApiGetActivityStatisticsRequest, options?: AxiosRequestConfig) {
        return ActivityApiFp(this.configuration).getActivityStatistics(requestParameters.albumId, requestParameters.assetId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * AlbumApi - axios parameter creator
 * @export
 */
export const AlbumApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *
         * @param {string} id
         * @param {BulkIdsDto} bulkIdsDto
         * @param {string} [key]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addAssetsToAlbum: async (id: string, bulkIdsDto: BulkIdsDto, key?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('addAssetsToAlbum', 'id', id)
            // verify required parameter 'bulkIdsDto' is not null or undefined
            assertParamExists('addAssetsToAlbum', 'bulkIdsDto', bulkIdsDto)
            const localVarPath = `/album/{id}/assets`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookie required

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (key !== undefined) {
                localVarQueryParameter['key'] = key;
            }


            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(bulkIdsDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {string} id
         * @param {AddUsersDto} addUsersDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addUsersToAlbum: async (id: string, addUsersDto: AddUsersDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('addUsersToAlbum', 'id', id)
            // verify required parameter 'addUsersDto' is not null or undefined
            assertParamExists('addUsersToAlbum', 'addUsersDto', addUsersDto)
            const localVarPath = `/album/{id}/users`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookie required

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(addUsersDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {CreateAlbumDto} createAlbumDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAlbum: async (createAlbumDto: CreateAlbumDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createAlbumDto' is not null or undefined
            assertParamExists('createAlbum', 'createAlbumDto', createAlbumDto)
            const localVarPath = `/album`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookie required

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createAlbumDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAlbum: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteAlbum', 'id', id)
            const localVarPath = `/album/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookie required

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAlbumCount: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/album/count`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookie required

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {string} id
         * @param {boolean} [withoutAssets]
         * @param {string} [key]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAlbumInfo: async (id: string, withoutAssets?: boolean, key?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getAlbumInfo', 'id', id)
            const localVarPath = `/album/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookie required

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (withoutAssets !== undefined) {
                localVarQueryParameter['withoutAssets'] = withoutAssets;
            }

            if (key !== undefined) {
                localVarQueryParameter['key'] = key;
            }


            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {boolean} [shared]
         * @param {string} [assetId] Only returns albums that contain the asset Ignores the shared parameter undefined: get all albums
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllAlbums: async (shared?: boolean, assetId?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/album`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookie required

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (shared !== undefined) {
                localVarQueryParameter['shared'] = shared;
            }

            if (assetId !== undefined) {
                localVarQueryParameter['assetId'] = assetId;
            }


            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {string} id
         * @param {BulkIdsDto} bulkIdsDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeAssetFromAlbum: async (id: string, bulkIdsDto: BulkIdsDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('removeAssetFromAlbum', 'id', id)
            // verify required parameter 'bulkIdsDto' is not null or undefined
            assertParamExists('removeAssetFromAlbum', 'bulkIdsDto', bulkIdsDto)
            const localVarPath = `/album/{id}/assets`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookie required

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(bulkIdsDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {string} id
         * @param {string} userId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeUserFromAlbum: async (id: string, userId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('removeUserFromAlbum', 'id', id)
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('removeUserFromAlbum', 'userId', userId)
            const localVarPath = `/album/{id}/user/{userId}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookie required

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {string} id
         * @param {UpdateAlbumDto} updateAlbumDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAlbumInfo: async (id: string, updateAlbumDto: UpdateAlbumDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateAlbumInfo', 'id', id)
            // verify required parameter 'updateAlbumDto' is not null or undefined
            assertParamExists('updateAlbumInfo', 'updateAlbumDto', updateAlbumDto)
            const localVarPath = `/album/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookie required

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateAlbumDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AlbumApi - functional programming interface
 * @export
 */
export const AlbumApiFp = function (configuration?: Configuration) {
    const localVarAxiosParamCreator = AlbumApiAxiosParamCreator(configuration)
    return {
        /**
         *
         * @param {string} id
         * @param {BulkIdsDto} bulkIdsDto
         * @param {string} [key]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addAssetsToAlbum(id: string, bulkIdsDto: BulkIdsDto, key?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<BulkIdResponseDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addAssetsToAlbum(id, bulkIdsDto, key, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {string} id
         * @param {AddUsersDto} addUsersDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addUsersToAlbum(id: string, addUsersDto: AddUsersDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AlbumResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addUsersToAlbum(id, addUsersDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {CreateAlbumDto} createAlbumDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createAlbum(createAlbumDto: CreateAlbumDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AlbumResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createAlbum(createAlbumDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteAlbum(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteAlbum(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAlbumCount(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AlbumCountResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAlbumCount(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {string} id
         * @param {boolean} [withoutAssets]
         * @param {string} [key]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAlbumInfo(id: string, withoutAssets?: boolean, key?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AlbumResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAlbumInfo(id, withoutAssets, key, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {boolean} [shared]
         * @param {string} [assetId] Only returns albums that contain the asset Ignores the shared parameter undefined: get all albums
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllAlbums(shared?: boolean, assetId?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AlbumResponseDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllAlbums(shared, assetId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {string} id
         * @param {BulkIdsDto} bulkIdsDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async removeAssetFromAlbum(id: string, bulkIdsDto: BulkIdsDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<BulkIdResponseDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.removeAssetFromAlbum(id, bulkIdsDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {string} id
         * @param {string} userId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async removeUserFromAlbum(id: string, userId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.removeUserFromAlbum(id, userId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {string} id
         * @param {UpdateAlbumDto} updateAlbumDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateAlbumInfo(id: string, updateAlbumDto: UpdateAlbumDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AlbumResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateAlbumInfo(id, updateAlbumDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AlbumApi - factory interface
 * @export
 */
export const AlbumApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AlbumApiFp(configuration)
    return {
        /**
         *
         * @param {AlbumApiAddAssetsToAlbumRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addAssetsToAlbum(requestParameters: AlbumApiAddAssetsToAlbumRequest, options?: AxiosRequestConfig): AxiosPromise<Array<BulkIdResponseDto>> {
            return localVarFp.addAssetsToAlbum(requestParameters.id, requestParameters.bulkIdsDto, requestParameters.key, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {AlbumApiAddUsersToAlbumRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addUsersToAlbum(requestParameters: AlbumApiAddUsersToAlbumRequest, options?: AxiosRequestConfig): AxiosPromise<AlbumResponseDto> {
            return localVarFp.addUsersToAlbum(requestParameters.id, requestParameters.addUsersDto, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {AlbumApiCreateAlbumRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAlbum(requestParameters: AlbumApiCreateAlbumRequest, options?: AxiosRequestConfig): AxiosPromise<AlbumResponseDto> {
            return localVarFp.createAlbum(requestParameters.createAlbumDto, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {AlbumApiDeleteAlbumRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAlbum(requestParameters: AlbumApiDeleteAlbumRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteAlbum(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAlbumCount(options?: AxiosRequestConfig): AxiosPromise<AlbumCountResponseDto> {
            return localVarFp.getAlbumCount(options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {AlbumApiGetAlbumInfoRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAlbumInfo(requestParameters: AlbumApiGetAlbumInfoRequest, options?: AxiosRequestConfig): AxiosPromise<AlbumResponseDto> {
            return localVarFp.getAlbumInfo(requestParameters.id, requestParameters.withoutAssets, requestParameters.key, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {AlbumApiGetAllAlbumsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllAlbums(requestParameters: AlbumApiGetAllAlbumsRequest = {}, options?: AxiosRequestConfig): AxiosPromise<Array<AlbumResponseDto>> {
            return localVarFp.getAllAlbums(requestParameters.shared, requestParameters.assetId, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {AlbumApiRemoveAssetFromAlbumRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeAssetFromAlbum(requestParameters: AlbumApiRemoveAssetFromAlbumRequest, options?: AxiosRequestConfig): AxiosPromise<Array<BulkIdResponseDto>> {
            return localVarFp.removeAssetFromAlbum(requestParameters.id, requestParameters.bulkIdsDto, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {AlbumApiRemoveUserFromAlbumRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeUserFromAlbum(requestParameters: AlbumApiRemoveUserFromAlbumRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.removeUserFromAlbum(requestParameters.id, requestParameters.userId, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {AlbumApiUpdateAlbumInfoRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAlbumInfo(requestParameters: AlbumApiUpdateAlbumInfoRequest, options?: AxiosRequestConfig): AxiosPromise<AlbumResponseDto> {
            return localVarFp.updateAlbumInfo(requestParameters.id, requestParameters.updateAlbumDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for addAssetsToAlbum operation in AlbumApi.
 * @export
 * @interface AlbumApiAddAssetsToAlbumRequest
 */
export interface AlbumApiAddAssetsToAlbumRequest {
    /**
     *
     * @type {string}
     * @memberof AlbumApiAddAssetsToAlbum
     */
    readonly id: string

    /**
     *
     * @type {BulkIdsDto}
     * @memberof AlbumApiAddAssetsToAlbum
     */
    readonly bulkIdsDto: BulkIdsDto

    /**
     *
     * @type {string}
     * @memberof AlbumApiAddAssetsToAlbum
     */
    readonly key?: string
}

/**
 * Request parameters for addUsersToAlbum operation in AlbumApi.
 * @export
 * @interface AlbumApiAddUsersToAlbumRequest
 */
export interface AlbumApiAddUsersToAlbumRequest {
    /**
     *
     * @type {string}
     * @memberof AlbumApiAddUsersToAlbum
     */
    readonly id: string

    /**
     *
     * @type {AddUsersDto}
     * @memberof AlbumApiAddUsersToAlbum
     */
    readonly addUsersDto: AddUsersDto
}

/**
 * Request parameters for createAlbum operation in AlbumApi.
 * @export
 * @interface AlbumApiCreateAlbumRequest
 */
export interface AlbumApiCreateAlbumRequest {
    /**
     *
     * @type {CreateAlbumDto}
     * @memberof AlbumApiCreateAlbum
     */
    readonly createAlbumDto: CreateAlbumDto
}

/**
 * Request parameters for deleteAlbum operation in AlbumApi.
 * @export
 * @interface AlbumApiDeleteAlbumRequest
 */
export interface AlbumApiDeleteAlbumRequest {
    /**
     *
     * @type {string}
     * @memberof AlbumApiDeleteAlbum
     */
    readonly id: string
}

/**
 * Request parameters for getAlbumInfo operation in AlbumApi.
 * @export
 * @interface AlbumApiGetAlbumInfoRequest
 */
export interface AlbumApiGetAlbumInfoRequest {
    /**
     *
     * @type {string}
     * @memberof AlbumApiGetAlbumInfo
     */
    readonly id: string

    /**
     *
     * @type {boolean}
     * @memberof AlbumApiGetAlbumInfo
     */
    readonly withoutAssets?: boolean

    /**
     *
     * @type {string}
     * @memberof AlbumApiGetAlbumInfo
     */
    readonly key?: string
}

/**
 * Request parameters for getAllAlbums operation in AlbumApi.
 * @export
 * @interface AlbumApiGetAllAlbumsRequest
 */
export interface AlbumApiGetAllAlbumsRequest {
    /**
     *
     * @type {boolean}
     * @memberof AlbumApiGetAllAlbums
     */
    readonly shared?: boolean

    /**
     * Only returns albums that contain the asset Ignores the shared parameter undefined: get all albums
     * @type {string}
     * @memberof AlbumApiGetAllAlbums
     */
    readonly assetId?: string
}

/**
 * Request parameters for removeAssetFromAlbum operation in AlbumApi.
 * @export
 * @interface AlbumApiRemoveAssetFromAlbumRequest
 */
export interface AlbumApiRemoveAssetFromAlbumRequest {
    /**
     *
     * @type {string}
     * @memberof AlbumApiRemoveAssetFromAlbum
     */
    readonly id: string

    /**
     *
     * @type {BulkIdsDto}
     * @memberof AlbumApiRemoveAssetFromAlbum
     */
    readonly bulkIdsDto: BulkIdsDto
}

/**
 * Request parameters for removeUserFromAlbum operation in AlbumApi.
 * @export
 * @interface AlbumApiRemoveUserFromAlbumRequest
 */
export interface AlbumApiRemoveUserFromAlbumRequest {
    /**
     *
     * @type {string}
     * @memberof AlbumApiRemoveUserFromAlbum
     */
    readonly id: string

    /**
     *
     * @type {string}
     * @memberof AlbumApiRemoveUserFromAlbum
     */
    readonly userId: string
}

/**
 * Request parameters for updateAlbumInfo operation in AlbumApi.
 * @export
 * @interface AlbumApiUpdateAlbumInfoRequest
 */
export interface AlbumApiUpdateAlbumInfoRequest {
    /**
     *
     * @type {string}
     * @memberof AlbumApiUpdateAlbumInfo
     */
    readonly id: string

    /**
     *
     * @type {UpdateAlbumDto}
     * @memberof AlbumApiUpdateAlbumInfo
     */
    readonly updateAlbumDto: UpdateAlbumDto
}

/**
 * AlbumApi - object-oriented interface
 * @export
 * @class AlbumApi
 * @extends {BaseAPI}
 */
export class AlbumApi extends BaseAPI {
    /**
     *
     * @param {AlbumApiAddAssetsToAlbumRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlbumApi
     */
    public addAssetsToAlbum(requestParameters: AlbumApiAddAssetsToAlbumRequest, options?: AxiosRequestConfig) {
        return AlbumApiFp(this.configuration).addAssetsToAlbum(requestParameters.id, requestParameters.bulkIdsDto, requestParameters.key, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {AlbumApiAddUsersToAlbumRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlbumApi
     */
    public addUsersToAlbum(requestParameters: AlbumApiAddUsersToAlbumRequest, options?: AxiosRequestConfig) {
        return AlbumApiFp(this.configuration).addUsersToAlbum(requestParameters.id, requestParameters.addUsersDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {AlbumApiCreateAlbumRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlbumApi
     */
    public createAlbum(requestParameters: AlbumApiCreateAlbumRequest, options?: AxiosRequestConfig) {
        return AlbumApiFp(this.configuration).createAlbum(requestParameters.createAlbumDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {AlbumApiDeleteAlbumRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlbumApi
     */
    public deleteAlbum(requestParameters: AlbumApiDeleteAlbumRequest, options?: AxiosRequestConfig) {
        return AlbumApiFp(this.configuration).deleteAlbum(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlbumApi
     */
    public getAlbumCount(options?: AxiosRequestConfig) {
        return AlbumApiFp(this.configuration).getAlbumCount(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {AlbumApiGetAlbumInfoRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlbumApi
     */
    public getAlbumInfo(requestParameters: AlbumApiGetAlbumInfoRequest, options?: AxiosRequestConfig) {
        return AlbumApiFp(this.configuration).getAlbumInfo(requestParameters.id, requestParameters.withoutAssets, requestParameters.key, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {AlbumApiGetAllAlbumsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlbumApi
     */
    public getAllAlbums(requestParameters: AlbumApiGetAllAlbumsRequest = {}, options?: AxiosRequestConfig) {
        return AlbumApiFp(this.configuration).getAllAlbums(requestParameters.shared, requestParameters.assetId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {AlbumApiRemoveAssetFromAlbumRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlbumApi
     */
    public removeAssetFromAlbum(requestParameters: AlbumApiRemoveAssetFromAlbumRequest, options?: AxiosRequestConfig) {
        return AlbumApiFp(this.configuration).removeAssetFromAlbum(requestParameters.id, requestParameters.bulkIdsDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {AlbumApiRemoveUserFromAlbumRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlbumApi
     */
    public removeUserFromAlbum(requestParameters: AlbumApiRemoveUserFromAlbumRequest, options?: AxiosRequestConfig) {
        return AlbumApiFp(this.configuration).removeUserFromAlbum(requestParameters.id, requestParameters.userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {AlbumApiUpdateAlbumInfoRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlbumApi
     */
    public updateAlbumInfo(requestParameters: AlbumApiUpdateAlbumInfoRequest, options?: AxiosRequestConfig) {
        return AlbumApiFp(this.configuration).updateAlbumInfo(requestParameters.id, requestParameters.updateAlbumDto, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * AssetApi - axios parameter creator
 * @export
 */
export const AssetApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Checks if assets exist by checksums
         * @param {AssetBulkUploadCheckDto} assetBulkUploadCheckDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkBulkUpload: async (assetBulkUploadCheckDto: AssetBulkUploadCheckDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'assetBulkUploadCheckDto' is not null or undefined
            assertParamExists('checkBulkUpload', 'assetBulkUploadCheckDto', assetBulkUploadCheckDto)
            const localVarPath = `/asset/bulk-upload-check`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookie required

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(assetBulkUploadCheckDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Checks if multiple assets exist on the server and returns all existing - used by background backup
         * @param {CheckExistingAssetsDto} checkExistingAssetsDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkExistingAssets: async (checkExistingAssetsDto: CheckExistingAssetsDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'checkExistingAssetsDto' is not null or undefined
            assertParamExists('checkExistingAssets', 'checkExistingAssetsDto', checkExistingAssetsDto)
            const localVarPath = `/asset/exist`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookie required

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(checkExistingAssetsDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {AssetBulkDeleteDto} assetBulkDeleteDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAssets: async (assetBulkDeleteDto: AssetBulkDeleteDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'assetBulkDeleteDto' is not null or undefined
            assertParamExists('deleteAssets', 'assetBulkDeleteDto', assetBulkDeleteDto)
            const localVarPath = `/asset`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookie required

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(assetBulkDeleteDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {AssetIdsDto} assetIdsDto
         * @param {string} [key]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadArchive: async (assetIdsDto: AssetIdsDto, key?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'assetIdsDto' is not null or undefined
            assertParamExists('downloadArchive', 'assetIdsDto', assetIdsDto)
            const localVarPath = `/asset/download/archive`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookie required

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (key !== undefined) {
                localVarQueryParameter['key'] = key;
            }


            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(assetIdsDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {string} id
         * @param {string} [key]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadFile: async (id: string, key?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('downloadFile', 'id', id)
            const localVarPath = `/asset/download/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookie required

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (key !== undefined) {
                localVarQueryParameter['key'] = key;
            }


            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        emptyTrash: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/asset/trash/empty`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookie required

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all AssetEntity belong to the user
         * @param {number} [skip]
         * @param {number} [take]
         * @param {string} [userId]
         * @param {boolean} [isFavorite]
         * @param {boolean} [isArchived]
         * @param {string} [updatedAfter]
         * @param {string} [updatedBefore]
         * @param {string} [ifNoneMatch] ETag of data already cached on the client
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllAssets: async (skip?: number, take?: number, userId?: string, isFavorite?: boolean, isArchived?: boolean, updatedAfter?: string, updatedBefore?: string, ifNoneMatch?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/asset`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookie required

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }

            if (take !== undefined) {
                localVarQueryParameter['take'] = take;
            }

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (isFavorite !== undefined) {
                localVarQueryParameter['isFavorite'] = isFavorite;
            }

            if (isArchived !== undefined) {
                localVarQueryParameter['isArchived'] = isArchived;
            }

            if (updatedAfter !== undefined) {
                localVarQueryParameter['updatedAfter'] = (updatedAfter as any instanceof Date) ?
                    (updatedAfter as any).toISOString() :
                    updatedAfter;
            }

            if (updatedBefore !== undefined) {
                localVarQueryParameter['updatedBefore'] = (updatedBefore as any instanceof Date) ?
                    (updatedBefore as any).toISOString() :
                    updatedBefore;
            }

            if (ifNoneMatch != null) {
                localVarHeaderParameter['if-none-match'] = String(ifNoneMatch);
            }


            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all asset of a device that are in the database, ID only.
         * @param {string} deviceId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllUserAssetsByDeviceId: async (deviceId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'deviceId' is not null or undefined
            assertParamExists('getAllUserAssetsByDeviceId', 'deviceId', deviceId)
            const localVarPath = `/asset/device/{deviceId}`
                .replace(`{${"deviceId"}}`, encodeURIComponent(String(deviceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookie required

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a single asset\'s information
         * @param {string} id
         * @param {string} [key]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAssetById: async (id: string, key?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getAssetById', 'id', id)
            const localVarPath = `/asset/assetById/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookie required

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (key !== undefined) {
                localVarQueryParameter['key'] = key;
            }


            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAssetSearchTerms: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/asset/search-terms`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookie required

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {boolean} [isArchived]
         * @param {boolean} [isFavorite]
         * @param {boolean} [isTrashed]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAssetStatistics: async (isArchived?: boolean, isFavorite?: boolean, isTrashed?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/asset/statistics`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookie required

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (isArchived !== undefined) {
                localVarQueryParameter['isArchived'] = isArchived;
            }

            if (isFavorite !== undefined) {
                localVarQueryParameter['isFavorite'] = isFavorite;
            }

            if (isTrashed !== undefined) {
                localVarQueryParameter['isTrashed'] = isTrashed;
            }


            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {string} id
         * @param {ThumbnailFormat} [format]
         * @param {string} [key]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAssetThumbnail: async (id: string, format?: ThumbnailFormat, key?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getAssetThumbnail', 'id', id)
            const localVarPath = `/asset/thumbnail/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookie required

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (format !== undefined) {
                localVarQueryParameter['format'] = format;
            }

            if (key !== undefined) {
                localVarQueryParameter['key'] = key;
            }


            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCuratedLocations: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/asset/curated-locations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookie required

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCuratedObjects: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/asset/curated-objects`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookie required

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {DownloadInfoDto} downloadInfoDto
         * @param {string} [key]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDownloadInfo: async (downloadInfoDto: DownloadInfoDto, key?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'downloadInfoDto' is not null or undefined
            assertParamExists('getDownloadInfo', 'downloadInfoDto', downloadInfoDto)
            const localVarPath = `/asset/download/info`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookie required

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (key !== undefined) {
                localVarQueryParameter['key'] = key;
            }


            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(downloadInfoDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {boolean} [isArchived]
         * @param {boolean} [isFavorite]
         * @param {string} [fileCreatedAfter]
         * @param {string} [fileCreatedBefore]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMapMarkers: async (isArchived?: boolean, isFavorite?: boolean, fileCreatedAfter?: string, fileCreatedBefore?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/asset/map-marker`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookie required

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (isArchived !== undefined) {
                localVarQueryParameter['isArchived'] = isArchived;
            }

            if (isFavorite !== undefined) {
                localVarQueryParameter['isFavorite'] = isFavorite;
            }

            if (fileCreatedAfter !== undefined) {
                localVarQueryParameter['fileCreatedAfter'] = (fileCreatedAfter as any instanceof Date) ?
                    (fileCreatedAfter as any).toISOString() :
                    fileCreatedAfter;
            }

            if (fileCreatedBefore !== undefined) {
                localVarQueryParameter['fileCreatedBefore'] = (fileCreatedBefore as any instanceof Date) ?
                    (fileCreatedBefore as any).toISOString() :
                    fileCreatedBefore;
            }


            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {number} day
         * @param {number} month
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMemoryLane: async (day: number, month: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'day' is not null or undefined
            assertParamExists('getMemoryLane', 'day', day)
            // verify required parameter 'month' is not null or undefined
            assertParamExists('getMemoryLane', 'month', month)
            const localVarPath = `/asset/memory-lane`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookie required

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (day !== undefined) {
                localVarQueryParameter['day'] = day;
            }

            if (month !== undefined) {
                localVarQueryParameter['month'] = month;
            }


            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {number} [count]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRandom: async (count?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/asset/random`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookie required

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }


            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {TimeBucketSize} size
         * @param {string} timeBucket
         * @param {string} [userId]
         * @param {string} [albumId]
         * @param {string} [personId]
         * @param {boolean} [isArchived]
         * @param {boolean} [isFavorite]
         * @param {boolean} [isTrashed]
         * @param {boolean} [withStacked]
         * @param {boolean} [withPartners]
         * @param {string} [key]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTimeBucket: async (size: TimeBucketSize, timeBucket: string, userId?: string, albumId?: string, personId?: string, isArchived?: boolean, isFavorite?: boolean, isTrashed?: boolean, withStacked?: boolean, withPartners?: boolean, key?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'size' is not null or undefined
            assertParamExists('getTimeBucket', 'size', size)
            // verify required parameter 'timeBucket' is not null or undefined
            assertParamExists('getTimeBucket', 'timeBucket', timeBucket)
            const localVarPath = `/asset/time-bucket`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookie required

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (albumId !== undefined) {
                localVarQueryParameter['albumId'] = albumId;
            }

            if (personId !== undefined) {
                localVarQueryParameter['personId'] = personId;
            }

            if (isArchived !== undefined) {
                localVarQueryParameter['isArchived'] = isArchived;
            }

            if (isFavorite !== undefined) {
                localVarQueryParameter['isFavorite'] = isFavorite;
            }

            if (isTrashed !== undefined) {
                localVarQueryParameter['isTrashed'] = isTrashed;
            }

            if (withStacked !== undefined) {
                localVarQueryParameter['withStacked'] = withStacked;
            }

            if (withPartners !== undefined) {
                localVarQueryParameter['withPartners'] = withPartners;
            }

            if (timeBucket !== undefined) {
                localVarQueryParameter['timeBucket'] = timeBucket;
            }

            if (key !== undefined) {
                localVarQueryParameter['key'] = key;
            }


            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {TimeBucketSize} size
         * @param {string} [userId]
         * @param {string} [albumId]
         * @param {string} [personId]
         * @param {boolean} [isArchived]
         * @param {boolean} [isFavorite]
         * @param {boolean} [isTrashed]
         * @param {boolean} [withStacked]
         * @param {boolean} [withPartners]
         * @param {string} [key]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTimeBuckets: async (size: TimeBucketSize, userId?: string, albumId?: string, personId?: string, isArchived?: boolean, isFavorite?: boolean, isTrashed?: boolean, withStacked?: boolean, withPartners?: boolean, key?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'size' is not null or undefined
            assertParamExists('getTimeBuckets', 'size', size)
            const localVarPath = `/asset/time-buckets`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookie required

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (albumId !== undefined) {
                localVarQueryParameter['albumId'] = albumId;
            }

            if (personId !== undefined) {
                localVarQueryParameter['personId'] = personId;
            }

            if (isArchived !== undefined) {
                localVarQueryParameter['isArchived'] = isArchived;
            }

            if (isFavorite !== undefined) {
                localVarQueryParameter['isFavorite'] = isFavorite;
            }

            if (isTrashed !== undefined) {
                localVarQueryParameter['isTrashed'] = isTrashed;
            }

            if (withStacked !== undefined) {
                localVarQueryParameter['withStacked'] = withStacked;
            }

            if (withPartners !== undefined) {
                localVarQueryParameter['withPartners'] = withPartners;
            }

            if (key !== undefined) {
                localVarQueryParameter['key'] = key;
            }


            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Use /asset/device/:deviceId instead - Remove in 1.92 release
         * @param {string} deviceId
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        getUserAssetsByDeviceId: async (deviceId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'deviceId' is not null or undefined
            assertParamExists('getUserAssetsByDeviceId', 'deviceId', deviceId)
            const localVarPath = `/asset/{deviceId}`
                .replace(`{${"deviceId"}}`, encodeURIComponent(String(deviceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookie required

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {BulkIdsDto} bulkIdsDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        restoreAssets: async (bulkIdsDto: BulkIdsDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'bulkIdsDto' is not null or undefined
            assertParamExists('restoreAssets', 'bulkIdsDto', bulkIdsDto)
            const localVarPath = `/asset/restore`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookie required

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(bulkIdsDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        restoreTrash: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/asset/trash/restore`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookie required

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {AssetJobsDto} assetJobsDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        runAssetJobs: async (assetJobsDto: AssetJobsDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'assetJobsDto' is not null or undefined
            assertParamExists('runAssetJobs', 'assetJobsDto', assetJobsDto)
            const localVarPath = `/asset/jobs`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookie required

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(assetJobsDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {string} [id]
         * @param {string} [libraryId]
         * @param {AssetTypeEnum} [type]
         * @param {AssetOrder} [order]
         * @param {string} [deviceAssetId]
         * @param {string} [deviceId]
         * @param {string} [checksum]
         * @param {boolean} [isArchived]
         * @param {boolean} [isEncoded]
         * @param {boolean} [isExternal]
         * @param {boolean} [isFavorite]
         * @param {boolean} [isMotion]
         * @param {boolean} [isOffline]
         * @param {boolean} [isReadOnly]
         * @param {boolean} [isVisible]
         * @param {boolean} [withDeleted]
         * @param {boolean} [withStacked]
         * @param {boolean} [withExif]
         * @param {boolean} [withPeople]
         * @param {string} [createdBefore]
         * @param {string} [createdAfter]
         * @param {string} [updatedBefore]
         * @param {string} [updatedAfter]
         * @param {string} [trashedBefore]
         * @param {string} [trashedAfter]
         * @param {string} [takenBefore]
         * @param {string} [takenAfter]
         * @param {string} [originalFileName]
         * @param {string} [originalPath]
         * @param {string} [resizePath]
         * @param {string} [webpPath]
         * @param {string} [encodedVideoPath]
         * @param {string} [city]
         * @param {string} [state]
         * @param {string} [country]
         * @param {string} [make]
         * @param {string} [model]
         * @param {string} [lensModel]
         * @param {number} [page]
         * @param {number} [size]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchAssets: async (id?: string, libraryId?: string, type?: AssetTypeEnum, order?: AssetOrder, deviceAssetId?: string, deviceId?: string, checksum?: string, isArchived?: boolean, isEncoded?: boolean, isExternal?: boolean, isFavorite?: boolean, isMotion?: boolean, isOffline?: boolean, isReadOnly?: boolean, isVisible?: boolean, withDeleted?: boolean, withStacked?: boolean, withExif?: boolean, withPeople?: boolean, createdBefore?: string, createdAfter?: string, updatedBefore?: string, updatedAfter?: string, trashedBefore?: string, trashedAfter?: string, takenBefore?: string, takenAfter?: string, originalFileName?: string, originalPath?: string, resizePath?: string, webpPath?: string, encodedVideoPath?: string, city?: string, state?: string, country?: string, make?: string, model?: string, lensModel?: string, page?: number, size?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/assets`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookie required

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (libraryId !== undefined) {
                localVarQueryParameter['libraryId'] = libraryId;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (deviceAssetId !== undefined) {
                localVarQueryParameter['deviceAssetId'] = deviceAssetId;
            }

            if (deviceId !== undefined) {
                localVarQueryParameter['deviceId'] = deviceId;
            }

            if (checksum !== undefined) {
                localVarQueryParameter['checksum'] = checksum;
            }

            if (isArchived !== undefined) {
                localVarQueryParameter['isArchived'] = isArchived;
            }

            if (isEncoded !== undefined) {
                localVarQueryParameter['isEncoded'] = isEncoded;
            }

            if (isExternal !== undefined) {
                localVarQueryParameter['isExternal'] = isExternal;
            }

            if (isFavorite !== undefined) {
                localVarQueryParameter['isFavorite'] = isFavorite;
            }

            if (isMotion !== undefined) {
                localVarQueryParameter['isMotion'] = isMotion;
            }

            if (isOffline !== undefined) {
                localVarQueryParameter['isOffline'] = isOffline;
            }

            if (isReadOnly !== undefined) {
                localVarQueryParameter['isReadOnly'] = isReadOnly;
            }

            if (isVisible !== undefined) {
                localVarQueryParameter['isVisible'] = isVisible;
            }

            if (withDeleted !== undefined) {
                localVarQueryParameter['withDeleted'] = withDeleted;
            }

            if (withStacked !== undefined) {
                localVarQueryParameter['withStacked'] = withStacked;
            }

            if (withExif !== undefined) {
                localVarQueryParameter['withExif'] = withExif;
            }

            if (withPeople !== undefined) {
                localVarQueryParameter['withPeople'] = withPeople;
            }

            if (createdBefore !== undefined) {
                localVarQueryParameter['createdBefore'] = (createdBefore as any instanceof Date) ?
                    (createdBefore as any).toISOString() :
                    createdBefore;
            }

            if (createdAfter !== undefined) {
                localVarQueryParameter['createdAfter'] = (createdAfter as any instanceof Date) ?
                    (createdAfter as any).toISOString() :
                    createdAfter;
            }

            if (updatedBefore !== undefined) {
                localVarQueryParameter['updatedBefore'] = (updatedBefore as any instanceof Date) ?
                    (updatedBefore as any).toISOString() :
                    updatedBefore;
            }

            if (updatedAfter !== undefined) {
                localVarQueryParameter['updatedAfter'] = (updatedAfter as any instanceof Date) ?
                    (updatedAfter as any).toISOString() :
                    updatedAfter;
            }

            if (trashedBefore !== undefined) {
                localVarQueryParameter['trashedBefore'] = (trashedBefore as any instanceof Date) ?
                    (trashedBefore as any).toISOString() :
                    trashedBefore;
            }

            if (trashedAfter !== undefined) {
                localVarQueryParameter['trashedAfter'] = (trashedAfter as any instanceof Date) ?
                    (trashedAfter as any).toISOString() :
                    trashedAfter;
            }

            if (takenBefore !== undefined) {
                localVarQueryParameter['takenBefore'] = (takenBefore as any instanceof Date) ?
                    (takenBefore as any).toISOString() :
                    takenBefore;
            }

            if (takenAfter !== undefined) {
                localVarQueryParameter['takenAfter'] = (takenAfter as any instanceof Date) ?
                    (takenAfter as any).toISOString() :
                    takenAfter;
            }

            if (originalFileName !== undefined) {
                localVarQueryParameter['originalFileName'] = originalFileName;
            }

            if (originalPath !== undefined) {
                localVarQueryParameter['originalPath'] = originalPath;
            }

            if (resizePath !== undefined) {
                localVarQueryParameter['resizePath'] = resizePath;
            }

            if (webpPath !== undefined) {
                localVarQueryParameter['webpPath'] = webpPath;
            }

            if (encodedVideoPath !== undefined) {
                localVarQueryParameter['encodedVideoPath'] = encodedVideoPath;
            }

            if (city !== undefined) {
                localVarQueryParameter['city'] = city;
            }

            if (state !== undefined) {
                localVarQueryParameter['state'] = state;
            }

            if (country !== undefined) {
                localVarQueryParameter['country'] = country;
            }

            if (make !== undefined) {
                localVarQueryParameter['make'] = make;
            }

            if (model !== undefined) {
                localVarQueryParameter['model'] = model;
            }

            if (lensModel !== undefined) {
                localVarQueryParameter['lensModel'] = lensModel;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }


            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {string} id
         * @param {boolean} [isThumb]
         * @param {boolean} [isWeb]
         * @param {string} [key]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        serveFile: async (id: string, isThumb?: boolean, isWeb?: boolean, key?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('serveFile', 'id', id)
            const localVarPath = `/asset/file/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookie required

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (isThumb !== undefined) {
                localVarQueryParameter['isThumb'] = isThumb;
            }

            if (isWeb !== undefined) {
                localVarQueryParameter['isWeb'] = isWeb;
            }

            if (key !== undefined) {
                localVarQueryParameter['key'] = key;
            }


            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {string} id
         * @param {UpdateAssetDto} updateAssetDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAsset: async (id: string, updateAssetDto: UpdateAssetDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateAsset', 'id', id)
            // verify required parameter 'updateAssetDto' is not null or undefined
            assertParamExists('updateAsset', 'updateAssetDto', updateAssetDto)
            const localVarPath = `/asset/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookie required

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateAssetDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {AssetBulkUpdateDto} assetBulkUpdateDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAssets: async (assetBulkUpdateDto: AssetBulkUpdateDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'assetBulkUpdateDto' is not null or undefined
            assertParamExists('updateAssets', 'assetBulkUpdateDto', assetBulkUpdateDto)
            const localVarPath = `/asset`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookie required

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(assetBulkUpdateDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {UpdateStackParentDto} updateStackParentDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateStackParent: async (updateStackParentDto: UpdateStackParentDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'updateStackParentDto' is not null or undefined
            assertParamExists('updateStackParent', 'updateStackParentDto', updateStackParentDto)
            const localVarPath = `/asset/stack/parent`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookie required

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateStackParentDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {File} assetData
         * @param {string} deviceAssetId
         * @param {string} deviceId
         * @param {string} fileCreatedAt
         * @param {string} fileModifiedAt
         * @param {string} [key]
         * @param {string} [duration]
         * @param {boolean} [isArchived]
         * @param {boolean} [isExternal]
         * @param {boolean} [isFavorite]
         * @param {boolean} [isOffline]
         * @param {boolean} [isReadOnly]
         * @param {boolean} [isVisible]
         * @param {string} [libraryId]
         * @param {File} [livePhotoData]
         * @param {File} [sidecarData]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadFile: async (assetData: File, deviceAssetId: string, deviceId: string, fileCreatedAt: string, fileModifiedAt: string, key?: string, duration?: string, isArchived?: boolean, isExternal?: boolean, isFavorite?: boolean, isOffline?: boolean, isReadOnly?: boolean, isVisible?: boolean, libraryId?: string, livePhotoData?: File, sidecarData?: File, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'assetData' is not null or undefined
            assertParamExists('uploadFile', 'assetData', assetData)
            // verify required parameter 'deviceAssetId' is not null or undefined
            assertParamExists('uploadFile', 'deviceAssetId', deviceAssetId)
            // verify required parameter 'deviceId' is not null or undefined
            assertParamExists('uploadFile', 'deviceId', deviceId)
            // verify required parameter 'fileCreatedAt' is not null or undefined
            assertParamExists('uploadFile', 'fileCreatedAt', fileCreatedAt)
            // verify required parameter 'fileModifiedAt' is not null or undefined
            assertParamExists('uploadFile', 'fileModifiedAt', fileModifiedAt)
            const localVarPath = `/asset/upload`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication cookie required

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (key !== undefined) {
                localVarQueryParameter['key'] = key;
            }


            if (assetData !== undefined) {
                localVarFormParams.append('assetData', assetData as any);
            }

            if (deviceAssetId !== undefined) {
                localVarFormParams.append('deviceAssetId', deviceAssetId as any);
            }

            if (deviceId !== undefined) {
                localVarFormParams.append('deviceId', deviceId as any);
            }

            if (duration !== undefined) {
                localVarFormParams.append('duration', duration as any);
            }

            if (fileCreatedAt !== undefined) {
                localVarFormParams.append('fileCreatedAt', fileCreatedAt as any);
            }

            if (fileModifiedAt !== undefined) {
                localVarFormParams.append('fileModifiedAt', fileModifiedAt as any);
            }

            if (isArchived !== undefined) {
                localVarFormParams.append('isArchived', isArchived as any);
            }

            if (isExternal !== undefined) {
                localVarFormParams.append('isExternal', isExternal as any);
            }

            if (isFavorite !== undefined) {
                localVarFormParams.append('isFavorite', isFavorite as any);
            }

            if (isOffline !== undefined) {
                localVarFormParams.append('isOffline', isOffline as any);
            }

            if (isReadOnly !== undefined) {
                localVarFormParams.append('isReadOnly', isReadOnly as any);
            }

            if (isVisible !== undefined) {
                localVarFormParams.append('isVisible', isVisible as any);
            }

            if (libraryId !== undefined) {
                localVarFormParams.append('libraryId', libraryId as any);
            }

            if (livePhotoData !== undefined) {
                localVarFormParams.append('livePhotoData', livePhotoData as any);
            }

            if (sidecarData !== undefined) {
                localVarFormParams.append('sidecarData', sidecarData as any);
            }


            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AssetApi - functional programming interface
 * @export
 */
export const AssetApiFp = function (configuration?: Configuration) {
    const localVarAxiosParamCreator = AssetApiAxiosParamCreator(configuration)
    return {
        /**
         * Checks if assets exist by checksums
         * @param {AssetBulkUploadCheckDto} assetBulkUploadCheckDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async checkBulkUpload(assetBulkUploadCheckDto: AssetBulkUploadCheckDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AssetBulkUploadCheckResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.checkBulkUpload(assetBulkUploadCheckDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Checks if multiple assets exist on the server and returns all existing - used by background backup
         * @param {CheckExistingAssetsDto} checkExistingAssetsDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async checkExistingAssets(checkExistingAssetsDto: CheckExistingAssetsDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CheckExistingAssetsResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.checkExistingAssets(checkExistingAssetsDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {AssetBulkDeleteDto} assetBulkDeleteDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteAssets(assetBulkDeleteDto: AssetBulkDeleteDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteAssets(assetBulkDeleteDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {AssetIdsDto} assetIdsDto
         * @param {string} [key]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async downloadArchive(assetIdsDto: AssetIdsDto, key?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<File>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.downloadArchive(assetIdsDto, key, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {string} id
         * @param {string} [key]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async downloadFile(id: string, key?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<File>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.downloadFile(id, key, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async emptyTrash(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.emptyTrash(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get all AssetEntity belong to the user
         * @param {number} [skip]
         * @param {number} [take]
         * @param {string} [userId]
         * @param {boolean} [isFavorite]
         * @param {boolean} [isArchived]
         * @param {string} [updatedAfter]
         * @param {string} [updatedBefore]
         * @param {string} [ifNoneMatch] ETag of data already cached on the client
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllAssets(skip?: number, take?: number, userId?: string, isFavorite?: boolean, isArchived?: boolean, updatedAfter?: string, updatedBefore?: string, ifNoneMatch?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AssetResponseDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllAssets(skip, take, userId, isFavorite, isArchived, updatedAfter, updatedBefore, ifNoneMatch, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get all asset of a device that are in the database, ID only.
         * @param {string} deviceId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllUserAssetsByDeviceId(deviceId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllUserAssetsByDeviceId(deviceId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a single asset\'s information
         * @param {string} id
         * @param {string} [key]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAssetById(id: string, key?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AssetResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAssetById(id, key, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAssetSearchTerms(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAssetSearchTerms(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {boolean} [isArchived]
         * @param {boolean} [isFavorite]
         * @param {boolean} [isTrashed]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAssetStatistics(isArchived?: boolean, isFavorite?: boolean, isTrashed?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AssetStatsResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAssetStatistics(isArchived, isFavorite, isTrashed, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {string} id
         * @param {ThumbnailFormat} [format]
         * @param {string} [key]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAssetThumbnail(id: string, format?: ThumbnailFormat, key?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<File>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAssetThumbnail(id, format, key, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCuratedLocations(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CuratedLocationsResponseDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCuratedLocations(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCuratedObjects(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CuratedObjectsResponseDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCuratedObjects(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {DownloadInfoDto} downloadInfoDto
         * @param {string} [key]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDownloadInfo(downloadInfoDto: DownloadInfoDto, key?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DownloadResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDownloadInfo(downloadInfoDto, key, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {boolean} [isArchived]
         * @param {boolean} [isFavorite]
         * @param {string} [fileCreatedAfter]
         * @param {string} [fileCreatedBefore]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMapMarkers(isArchived?: boolean, isFavorite?: boolean, fileCreatedAfter?: string, fileCreatedBefore?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<MapMarkerResponseDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMapMarkers(isArchived, isFavorite, fileCreatedAfter, fileCreatedBefore, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {number} day
         * @param {number} month
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMemoryLane(day: number, month: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<MemoryLaneResponseDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMemoryLane(day, month, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {number} [count]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRandom(count?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AssetResponseDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRandom(count, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {TimeBucketSize} size
         * @param {string} timeBucket
         * @param {string} [userId]
         * @param {string} [albumId]
         * @param {string} [personId]
         * @param {boolean} [isArchived]
         * @param {boolean} [isFavorite]
         * @param {boolean} [isTrashed]
         * @param {boolean} [withStacked]
         * @param {boolean} [withPartners]
         * @param {string} [key]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTimeBucket(size: TimeBucketSize, timeBucket: string, userId?: string, albumId?: string, personId?: string, isArchived?: boolean, isFavorite?: boolean, isTrashed?: boolean, withStacked?: boolean, withPartners?: boolean, key?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AssetResponseDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTimeBucket(size, timeBucket, userId, albumId, personId, isArchived, isFavorite, isTrashed, withStacked, withPartners, key, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {TimeBucketSize} size
         * @param {string} [userId]
         * @param {string} [albumId]
         * @param {string} [personId]
         * @param {boolean} [isArchived]
         * @param {boolean} [isFavorite]
         * @param {boolean} [isTrashed]
         * @param {boolean} [withStacked]
         * @param {boolean} [withPartners]
         * @param {string} [key]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTimeBuckets(size: TimeBucketSize, userId?: string, albumId?: string, personId?: string, isArchived?: boolean, isFavorite?: boolean, isTrashed?: boolean, withStacked?: boolean, withPartners?: boolean, key?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TimeBucketResponseDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTimeBuckets(size, userId, albumId, personId, isArchived, isFavorite, isTrashed, withStacked, withPartners, key, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Use /asset/device/:deviceId instead - Remove in 1.92 release
         * @param {string} deviceId
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async getUserAssetsByDeviceId(deviceId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserAssetsByDeviceId(deviceId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {BulkIdsDto} bulkIdsDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async restoreAssets(bulkIdsDto: BulkIdsDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.restoreAssets(bulkIdsDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async restoreTrash(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.restoreTrash(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {AssetJobsDto} assetJobsDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async runAssetJobs(assetJobsDto: AssetJobsDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.runAssetJobs(assetJobsDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {string} [id]
         * @param {string} [libraryId]
         * @param {AssetTypeEnum} [type]
         * @param {AssetOrder} [order]
         * @param {string} [deviceAssetId]
         * @param {string} [deviceId]
         * @param {string} [checksum]
         * @param {boolean} [isArchived]
         * @param {boolean} [isEncoded]
         * @param {boolean} [isExternal]
         * @param {boolean} [isFavorite]
         * @param {boolean} [isMotion]
         * @param {boolean} [isOffline]
         * @param {boolean} [isReadOnly]
         * @param {boolean} [isVisible]
         * @param {boolean} [withDeleted]
         * @param {boolean} [withStacked]
         * @param {boolean} [withExif]
         * @param {boolean} [withPeople]
         * @param {string} [createdBefore]
         * @param {string} [createdAfter]
         * @param {string} [updatedBefore]
         * @param {string} [updatedAfter]
         * @param {string} [trashedBefore]
         * @param {string} [trashedAfter]
         * @param {string} [takenBefore]
         * @param {string} [takenAfter]
         * @param {string} [originalFileName]
         * @param {string} [originalPath]
         * @param {string} [resizePath]
         * @param {string} [webpPath]
         * @param {string} [encodedVideoPath]
         * @param {string} [city]
         * @param {string} [state]
         * @param {string} [country]
         * @param {string} [make]
         * @param {string} [model]
         * @param {string} [lensModel]
         * @param {number} [page]
         * @param {number} [size]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchAssets(id?: string, libraryId?: string, type?: AssetTypeEnum, order?: AssetOrder, deviceAssetId?: string, deviceId?: string, checksum?: string, isArchived?: boolean, isEncoded?: boolean, isExternal?: boolean, isFavorite?: boolean, isMotion?: boolean, isOffline?: boolean, isReadOnly?: boolean, isVisible?: boolean, withDeleted?: boolean, withStacked?: boolean, withExif?: boolean, withPeople?: boolean, createdBefore?: string, createdAfter?: string, updatedBefore?: string, updatedAfter?: string, trashedBefore?: string, trashedAfter?: string, takenBefore?: string, takenAfter?: string, originalFileName?: string, originalPath?: string, resizePath?: string, webpPath?: string, encodedVideoPath?: string, city?: string, state?: string, country?: string, make?: string, model?: string, lensModel?: string, page?: number, size?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AssetResponseDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchAssets(id, libraryId, type, order, deviceAssetId, deviceId, checksum, isArchived, isEncoded, isExternal, isFavorite, isMotion, isOffline, isReadOnly, isVisible, withDeleted, withStacked, withExif, withPeople, createdBefore, createdAfter, updatedBefore, updatedAfter, trashedBefore, trashedAfter, takenBefore, takenAfter, originalFileName, originalPath, resizePath, webpPath, encodedVideoPath, city, state, country, make, model, lensModel, page, size, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {string} id
         * @param {boolean} [isThumb]
         * @param {boolean} [isWeb]
         * @param {string} [key]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async serveFile(id: string, isThumb?: boolean, isWeb?: boolean, key?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<File>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.serveFile(id, isThumb, isWeb, key, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {string} id
         * @param {UpdateAssetDto} updateAssetDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateAsset(id: string, updateAssetDto: UpdateAssetDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AssetResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateAsset(id, updateAssetDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {AssetBulkUpdateDto} assetBulkUpdateDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateAssets(assetBulkUpdateDto: AssetBulkUpdateDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateAssets(assetBulkUpdateDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {UpdateStackParentDto} updateStackParentDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateStackParent(updateStackParentDto: UpdateStackParentDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateStackParent(updateStackParentDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {File} assetData
         * @param {string} deviceAssetId
         * @param {string} deviceId
         * @param {string} fileCreatedAt
         * @param {string} fileModifiedAt
         * @param {string} [key]
         * @param {string} [duration]
         * @param {boolean} [isArchived]
         * @param {boolean} [isExternal]
         * @param {boolean} [isFavorite]
         * @param {boolean} [isOffline]
         * @param {boolean} [isReadOnly]
         * @param {boolean} [isVisible]
         * @param {string} [libraryId]
         * @param {File} [livePhotoData]
         * @param {File} [sidecarData]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async uploadFile(assetData: File, deviceAssetId: string, deviceId: string, fileCreatedAt: string, fileModifiedAt: string, key?: string, duration?: string, isArchived?: boolean, isExternal?: boolean, isFavorite?: boolean, isOffline?: boolean, isReadOnly?: boolean, isVisible?: boolean, libraryId?: string, livePhotoData?: File, sidecarData?: File, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AssetFileUploadResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.uploadFile(assetData, deviceAssetId, deviceId, fileCreatedAt, fileModifiedAt, key, duration, isArchived, isExternal, isFavorite, isOffline, isReadOnly, isVisible, libraryId, livePhotoData, sidecarData, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AssetApi - factory interface
 * @export
 */
export const AssetApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AssetApiFp(configuration)
    return {
        /**
         * Checks if assets exist by checksums
         * @param {AssetApiCheckBulkUploadRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkBulkUpload(requestParameters: AssetApiCheckBulkUploadRequest, options?: AxiosRequestConfig): AxiosPromise<AssetBulkUploadCheckResponseDto> {
            return localVarFp.checkBulkUpload(requestParameters.assetBulkUploadCheckDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Checks if multiple assets exist on the server and returns all existing - used by background backup
         * @param {AssetApiCheckExistingAssetsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkExistingAssets(requestParameters: AssetApiCheckExistingAssetsRequest, options?: AxiosRequestConfig): AxiosPromise<CheckExistingAssetsResponseDto> {
            return localVarFp.checkExistingAssets(requestParameters.checkExistingAssetsDto, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {AssetApiDeleteAssetsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAssets(requestParameters: AssetApiDeleteAssetsRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteAssets(requestParameters.assetBulkDeleteDto, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {AssetApiDownloadArchiveRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadArchive(requestParameters: AssetApiDownloadArchiveRequest, options?: AxiosRequestConfig): AxiosPromise<File> {
            return localVarFp.downloadArchive(requestParameters.assetIdsDto, requestParameters.key, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {AssetApiDownloadFileRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadFile(requestParameters: AssetApiDownloadFileRequest, options?: AxiosRequestConfig): AxiosPromise<File> {
            return localVarFp.downloadFile(requestParameters.id, requestParameters.key, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        emptyTrash(options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.emptyTrash(options).then((request) => request(axios, basePath));
        },
        /**
         * Get all AssetEntity belong to the user
         * @param {AssetApiGetAllAssetsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllAssets(requestParameters: AssetApiGetAllAssetsRequest = {}, options?: AxiosRequestConfig): AxiosPromise<Array<AssetResponseDto>> {
            return localVarFp.getAllAssets(requestParameters.skip, requestParameters.take, requestParameters.userId, requestParameters.isFavorite, requestParameters.isArchived, requestParameters.updatedAfter, requestParameters.updatedBefore, requestParameters.ifNoneMatch, options).then((request) => request(axios, basePath));
        },
        /**
         * Get all asset of a device that are in the database, ID only.
         * @param {AssetApiGetAllUserAssetsByDeviceIdRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllUserAssetsByDeviceId(requestParameters: AssetApiGetAllUserAssetsByDeviceIdRequest, options?: AxiosRequestConfig): AxiosPromise<Array<string>> {
            return localVarFp.getAllUserAssetsByDeviceId(requestParameters.deviceId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a single asset\'s information
         * @param {AssetApiGetAssetByIdRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAssetById(requestParameters: AssetApiGetAssetByIdRequest, options?: AxiosRequestConfig): AxiosPromise<AssetResponseDto> {
            return localVarFp.getAssetById(requestParameters.id, requestParameters.key, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAssetSearchTerms(options?: AxiosRequestConfig): AxiosPromise<Array<string>> {
            return localVarFp.getAssetSearchTerms(options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {AssetApiGetAssetStatisticsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAssetStatistics(requestParameters: AssetApiGetAssetStatisticsRequest = {}, options?: AxiosRequestConfig): AxiosPromise<AssetStatsResponseDto> {
            return localVarFp.getAssetStatistics(requestParameters.isArchived, requestParameters.isFavorite, requestParameters.isTrashed, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {AssetApiGetAssetThumbnailRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAssetThumbnail(requestParameters: AssetApiGetAssetThumbnailRequest, options?: AxiosRequestConfig): AxiosPromise<File> {
            return localVarFp.getAssetThumbnail(requestParameters.id, requestParameters.format, requestParameters.key, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCuratedLocations(options?: AxiosRequestConfig): AxiosPromise<Array<CuratedLocationsResponseDto>> {
            return localVarFp.getCuratedLocations(options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCuratedObjects(options?: AxiosRequestConfig): AxiosPromise<Array<CuratedObjectsResponseDto>> {
            return localVarFp.getCuratedObjects(options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {AssetApiGetDownloadInfoRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDownloadInfo(requestParameters: AssetApiGetDownloadInfoRequest, options?: AxiosRequestConfig): AxiosPromise<DownloadResponseDto> {
            return localVarFp.getDownloadInfo(requestParameters.downloadInfoDto, requestParameters.key, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {AssetApiGetMapMarkersRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMapMarkers(requestParameters: AssetApiGetMapMarkersRequest = {}, options?: AxiosRequestConfig): AxiosPromise<Array<MapMarkerResponseDto>> {
            return localVarFp.getMapMarkers(requestParameters.isArchived, requestParameters.isFavorite, requestParameters.fileCreatedAfter, requestParameters.fileCreatedBefore, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {AssetApiGetMemoryLaneRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMemoryLane(requestParameters: AssetApiGetMemoryLaneRequest, options?: AxiosRequestConfig): AxiosPromise<Array<MemoryLaneResponseDto>> {
            return localVarFp.getMemoryLane(requestParameters.day, requestParameters.month, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {AssetApiGetRandomRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRandom(requestParameters: AssetApiGetRandomRequest = {}, options?: AxiosRequestConfig): AxiosPromise<Array<AssetResponseDto>> {
            return localVarFp.getRandom(requestParameters.count, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {AssetApiGetTimeBucketRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTimeBucket(requestParameters: AssetApiGetTimeBucketRequest, options?: AxiosRequestConfig): AxiosPromise<Array<AssetResponseDto>> {
            return localVarFp.getTimeBucket(requestParameters.size, requestParameters.timeBucket, requestParameters.userId, requestParameters.albumId, requestParameters.personId, requestParameters.isArchived, requestParameters.isFavorite, requestParameters.isTrashed, requestParameters.withStacked, requestParameters.withPartners, requestParameters.key, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {AssetApiGetTimeBucketsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTimeBuckets(requestParameters: AssetApiGetTimeBucketsRequest, options?: AxiosRequestConfig): AxiosPromise<Array<TimeBucketResponseDto>> {
            return localVarFp.getTimeBuckets(requestParameters.size, requestParameters.userId, requestParameters.albumId, requestParameters.personId, requestParameters.isArchived, requestParameters.isFavorite, requestParameters.isTrashed, requestParameters.withStacked, requestParameters.withPartners, requestParameters.key, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Use /asset/device/:deviceId instead - Remove in 1.92 release
         * @param {AssetApiGetUserAssetsByDeviceIdRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        getUserAssetsByDeviceId(requestParameters: AssetApiGetUserAssetsByDeviceIdRequest, options?: AxiosRequestConfig): AxiosPromise<Array<string>> {
            return localVarFp.getUserAssetsByDeviceId(requestParameters.deviceId, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {AssetApiRestoreAssetsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        restoreAssets(requestParameters: AssetApiRestoreAssetsRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.restoreAssets(requestParameters.bulkIdsDto, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        restoreTrash(options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.restoreTrash(options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {AssetApiRunAssetJobsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        runAssetJobs(requestParameters: AssetApiRunAssetJobsRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.runAssetJobs(requestParameters.assetJobsDto, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {AssetApiSearchAssetsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchAssets(requestParameters: AssetApiSearchAssetsRequest = {}, options?: AxiosRequestConfig): AxiosPromise<Array<AssetResponseDto>> {
            return localVarFp.searchAssets(requestParameters.id, requestParameters.libraryId, requestParameters.type, requestParameters.order, requestParameters.deviceAssetId, requestParameters.deviceId, requestParameters.checksum, requestParameters.isArchived, requestParameters.isEncoded, requestParameters.isExternal, requestParameters.isFavorite, requestParameters.isMotion, requestParameters.isOffline, requestParameters.isReadOnly, requestParameters.isVisible, requestParameters.withDeleted, requestParameters.withStacked, requestParameters.withExif, requestParameters.withPeople, requestParameters.createdBefore, requestParameters.createdAfter, requestParameters.updatedBefore, requestParameters.updatedAfter, requestParameters.trashedBefore, requestParameters.trashedAfter, requestParameters.takenBefore, requestParameters.takenAfter, requestParameters.originalFileName, requestParameters.originalPath, requestParameters.resizePath, requestParameters.webpPath, requestParameters.encodedVideoPath, requestParameters.city, requestParameters.state, requestParameters.country, requestParameters.make, requestParameters.model, requestParameters.lensModel, requestParameters.page, requestParameters.size, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {AssetApiServeFileRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        serveFile(requestParameters: AssetApiServeFileRequest, options?: AxiosRequestConfig): AxiosPromise<File> {
            return localVarFp.serveFile(requestParameters.id, requestParameters.isThumb, requestParameters.isWeb, requestParameters.key, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {AssetApiUpdateAssetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAsset(requestParameters: AssetApiUpdateAssetRequest, options?: AxiosRequestConfig): AxiosPromise<AssetResponseDto> {
            return localVarFp.updateAsset(requestParameters.id, requestParameters.updateAssetDto, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {AssetApiUpdateAssetsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAssets(requestParameters: AssetApiUpdateAssetsRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.updateAssets(requestParameters.assetBulkUpdateDto, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {AssetApiUpdateStackParentRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateStackParent(requestParameters: AssetApiUpdateStackParentRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.updateStackParent(requestParameters.updateStackParentDto, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {AssetApiUploadFileRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadFile(requestParameters: AssetApiUploadFileRequest, options?: AxiosRequestConfig): AxiosPromise<AssetFileUploadResponseDto> {
            return localVarFp.uploadFile(requestParameters.assetData, requestParameters.deviceAssetId, requestParameters.deviceId, requestParameters.fileCreatedAt, requestParameters.fileModifiedAt, requestParameters.key, requestParameters.duration, requestParameters.isArchived, requestParameters.isExternal, requestParameters.isFavorite, requestParameters.isOffline, requestParameters.isReadOnly, requestParameters.isVisible, requestParameters.libraryId, requestParameters.livePhotoData, requestParameters.sidecarData, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for checkBulkUpload operation in AssetApi.
 * @export
 * @interface AssetApiCheckBulkUploadRequest
 */
export interface AssetApiCheckBulkUploadRequest {
    /**
     *
     * @type {AssetBulkUploadCheckDto}
     * @memberof AssetApiCheckBulkUpload
     */
    readonly assetBulkUploadCheckDto: AssetBulkUploadCheckDto
}

/**
 * Request parameters for checkExistingAssets operation in AssetApi.
 * @export
 * @interface AssetApiCheckExistingAssetsRequest
 */
export interface AssetApiCheckExistingAssetsRequest {
    /**
     *
     * @type {CheckExistingAssetsDto}
     * @memberof AssetApiCheckExistingAssets
     */
    readonly checkExistingAssetsDto: CheckExistingAssetsDto
}

/**
 * Request parameters for deleteAssets operation in AssetApi.
 * @export
 * @interface AssetApiDeleteAssetsRequest
 */
export interface AssetApiDeleteAssetsRequest {
    /**
     *
     * @type {AssetBulkDeleteDto}
     * @memberof AssetApiDeleteAssets
     */
    readonly assetBulkDeleteDto: AssetBulkDeleteDto
}

/**
 * Request parameters for downloadArchive operation in AssetApi.
 * @export
 * @interface AssetApiDownloadArchiveRequest
 */
export interface AssetApiDownloadArchiveRequest {
    /**
     *
     * @type {AssetIdsDto}
     * @memberof AssetApiDownloadArchive
     */
    readonly assetIdsDto: AssetIdsDto

    /**
     *
     * @type {string}
     * @memberof AssetApiDownloadArchive
     */
    readonly key?: string
}

/**
 * Request parameters for downloadFile operation in AssetApi.
 * @export
 * @interface AssetApiDownloadFileRequest
 */
export interface AssetApiDownloadFileRequest {
    /**
     *
     * @type {string}
     * @memberof AssetApiDownloadFile
     */
    readonly id: string

    /**
     *
     * @type {string}
     * @memberof AssetApiDownloadFile
     */
    readonly key?: string
}

/**
 * Request parameters for getAllAssets operation in AssetApi.
 * @export
 * @interface AssetApiGetAllAssetsRequest
 */
export interface AssetApiGetAllAssetsRequest {
    /**
     *
     * @type {number}
     * @memberof AssetApiGetAllAssets
     */
    readonly skip?: number

    /**
     *
     * @type {number}
     * @memberof AssetApiGetAllAssets
     */
    readonly take?: number

    /**
     *
     * @type {string}
     * @memberof AssetApiGetAllAssets
     */
    readonly userId?: string

    /**
     *
     * @type {boolean}
     * @memberof AssetApiGetAllAssets
     */
    readonly isFavorite?: boolean

    /**
     *
     * @type {boolean}
     * @memberof AssetApiGetAllAssets
     */
    readonly isArchived?: boolean

    /**
     *
     * @type {string}
     * @memberof AssetApiGetAllAssets
     */
    readonly updatedAfter?: string

    /**
     *
     * @type {string}
     * @memberof AssetApiGetAllAssets
     */
    readonly updatedBefore?: string

    /**
     * ETag of data already cached on the client
     * @type {string}
     * @memberof AssetApiGetAllAssets
     */
    readonly ifNoneMatch?: string
}

/**
 * Request parameters for getAllUserAssetsByDeviceId operation in AssetApi.
 * @export
 * @interface AssetApiGetAllUserAssetsByDeviceIdRequest
 */
export interface AssetApiGetAllUserAssetsByDeviceIdRequest {
    /**
     *
     * @type {string}
     * @memberof AssetApiGetAllUserAssetsByDeviceId
     */
    readonly deviceId: string
}

/**
 * Request parameters for getAssetById operation in AssetApi.
 * @export
 * @interface AssetApiGetAssetByIdRequest
 */
export interface AssetApiGetAssetByIdRequest {
    /**
     *
     * @type {string}
     * @memberof AssetApiGetAssetById
     */
    readonly id: string

    /**
     *
     * @type {string}
     * @memberof AssetApiGetAssetById
     */
    readonly key?: string
}

/**
 * Request parameters for getAssetStatistics operation in AssetApi.
 * @export
 * @interface AssetApiGetAssetStatisticsRequest
 */
export interface AssetApiGetAssetStatisticsRequest {
    /**
     *
     * @type {boolean}
     * @memberof AssetApiGetAssetStatistics
     */
    readonly isArchived?: boolean

    /**
     *
     * @type {boolean}
     * @memberof AssetApiGetAssetStatistics
     */
    readonly isFavorite?: boolean

    /**
     *
     * @type {boolean}
     * @memberof AssetApiGetAssetStatistics
     */
    readonly isTrashed?: boolean
}

/**
 * Request parameters for getAssetThumbnail operation in AssetApi.
 * @export
 * @interface AssetApiGetAssetThumbnailRequest
 */
export interface AssetApiGetAssetThumbnailRequest {
    /**
     *
     * @type {string}
     * @memberof AssetApiGetAssetThumbnail
     */
    readonly id: string

    /**
     *
     * @type {ThumbnailFormat}
     * @memberof AssetApiGetAssetThumbnail
     */
    readonly format?: ThumbnailFormat

    /**
     *
     * @type {string}
     * @memberof AssetApiGetAssetThumbnail
     */
    readonly key?: string
}

/**
 * Request parameters for getDownloadInfo operation in AssetApi.
 * @export
 * @interface AssetApiGetDownloadInfoRequest
 */
export interface AssetApiGetDownloadInfoRequest {
    /**
     *
     * @type {DownloadInfoDto}
     * @memberof AssetApiGetDownloadInfo
     */
    readonly downloadInfoDto: DownloadInfoDto

    /**
     *
     * @type {string}
     * @memberof AssetApiGetDownloadInfo
     */
    readonly key?: string
}

/**
 * Request parameters for getMapMarkers operation in AssetApi.
 * @export
 * @interface AssetApiGetMapMarkersRequest
 */
export interface AssetApiGetMapMarkersRequest {
    /**
     *
     * @type {boolean}
     * @memberof AssetApiGetMapMarkers
     */
    readonly isArchived?: boolean

    /**
     *
     * @type {boolean}
     * @memberof AssetApiGetMapMarkers
     */
    readonly isFavorite?: boolean

    /**
     *
     * @type {string}
     * @memberof AssetApiGetMapMarkers
     */
    readonly fileCreatedAfter?: string

    /**
     *
     * @type {string}
     * @memberof AssetApiGetMapMarkers
     */
    readonly fileCreatedBefore?: string
}

/**
 * Request parameters for getMemoryLane operation in AssetApi.
 * @export
 * @interface AssetApiGetMemoryLaneRequest
 */
export interface AssetApiGetMemoryLaneRequest {
    /**
     *
     * @type {number}
     * @memberof AssetApiGetMemoryLane
     */
    readonly day: number

    /**
     *
     * @type {number}
     * @memberof AssetApiGetMemoryLane
     */
    readonly month: number
}

/**
 * Request parameters for getRandom operation in AssetApi.
 * @export
 * @interface AssetApiGetRandomRequest
 */
export interface AssetApiGetRandomRequest {
    /**
     *
     * @type {number}
     * @memberof AssetApiGetRandom
     */
    readonly count?: number
}

/**
 * Request parameters for getTimeBucket operation in AssetApi.
 * @export
 * @interface AssetApiGetTimeBucketRequest
 */
export interface AssetApiGetTimeBucketRequest {
    /**
     *
     * @type {TimeBucketSize}
     * @memberof AssetApiGetTimeBucket
     */
    readonly size: TimeBucketSize

    /**
     *
     * @type {string}
     * @memberof AssetApiGetTimeBucket
     */
    readonly timeBucket: string

    /**
     *
     * @type {string}
     * @memberof AssetApiGetTimeBucket
     */
    readonly userId?: string

    /**
     *
     * @type {string}
     * @memberof AssetApiGetTimeBucket
     */
    readonly albumId?: string

    /**
     *
     * @type {string}
     * @memberof AssetApiGetTimeBucket
     */
    readonly personId?: string

    /**
     *
     * @type {boolean}
     * @memberof AssetApiGetTimeBucket
     */
    readonly isArchived?: boolean

    /**
     *
     * @type {boolean}
     * @memberof AssetApiGetTimeBucket
     */
    readonly isFavorite?: boolean

    /**
     *
     * @type {boolean}
     * @memberof AssetApiGetTimeBucket
     */
    readonly isTrashed?: boolean

    /**
     *
     * @type {boolean}
     * @memberof AssetApiGetTimeBucket
     */
    readonly withStacked?: boolean

    /**
     *
     * @type {boolean}
     * @memberof AssetApiGetTimeBucket
     */
    readonly withPartners?: boolean

    /**
     *
     * @type {string}
     * @memberof AssetApiGetTimeBucket
     */
    readonly key?: string
}

/**
 * Request parameters for getTimeBuckets operation in AssetApi.
 * @export
 * @interface AssetApiGetTimeBucketsRequest
 */
export interface AssetApiGetTimeBucketsRequest {
    /**
     *
     * @type {TimeBucketSize}
     * @memberof AssetApiGetTimeBuckets
     */
    readonly size: TimeBucketSize

    /**
     *
     * @type {string}
     * @memberof AssetApiGetTimeBuckets
     */
    readonly userId?: string

    /**
     *
     * @type {string}
     * @memberof AssetApiGetTimeBuckets
     */
    readonly albumId?: string

    /**
     *
     * @type {string}
     * @memberof AssetApiGetTimeBuckets
     */
    readonly personId?: string

    /**
     *
     * @type {boolean}
     * @memberof AssetApiGetTimeBuckets
     */
    readonly isArchived?: boolean

    /**
     *
     * @type {boolean}
     * @memberof AssetApiGetTimeBuckets
     */
    readonly isFavorite?: boolean

    /**
     *
     * @type {boolean}
     * @memberof AssetApiGetTimeBuckets
     */
    readonly isTrashed?: boolean

    /**
     *
     * @type {boolean}
     * @memberof AssetApiGetTimeBuckets
     */
    readonly withStacked?: boolean

    /**
     *
     * @type {boolean}
     * @memberof AssetApiGetTimeBuckets
     */
    readonly withPartners?: boolean

    /**
     *
     * @type {string}
     * @memberof AssetApiGetTimeBuckets
     */
    readonly key?: string
}

/**
 * Request parameters for getUserAssetsByDeviceId operation in AssetApi.
 * @export
 * @interface AssetApiGetUserAssetsByDeviceIdRequest
 */
export interface AssetApiGetUserAssetsByDeviceIdRequest {
    /**
     *
     * @type {string}
     * @memberof AssetApiGetUserAssetsByDeviceId
     */
    readonly deviceId: string
}

/**
 * Request parameters for restoreAssets operation in AssetApi.
 * @export
 * @interface AssetApiRestoreAssetsRequest
 */
export interface AssetApiRestoreAssetsRequest {
    /**
     *
     * @type {BulkIdsDto}
     * @memberof AssetApiRestoreAssets
     */
    readonly bulkIdsDto: BulkIdsDto
}

/**
 * Request parameters for runAssetJobs operation in AssetApi.
 * @export
 * @interface AssetApiRunAssetJobsRequest
 */
export interface AssetApiRunAssetJobsRequest {
    /**
     *
     * @type {AssetJobsDto}
     * @memberof AssetApiRunAssetJobs
     */
    readonly assetJobsDto: AssetJobsDto
}

/**
 * Request parameters for searchAssets operation in AssetApi.
 * @export
 * @interface AssetApiSearchAssetsRequest
 */
export interface AssetApiSearchAssetsRequest {
    /**
     *
     * @type {string}
     * @memberof AssetApiSearchAssets
     */
    readonly id?: string

    /**
     *
     * @type {string}
     * @memberof AssetApiSearchAssets
     */
    readonly libraryId?: string

    /**
     *
     * @type {AssetTypeEnum}
     * @memberof AssetApiSearchAssets
     */
    readonly type?: AssetTypeEnum

    /**
     *
     * @type {AssetOrder}
     * @memberof AssetApiSearchAssets
     */
    readonly order?: AssetOrder

    /**
     *
     * @type {string}
     * @memberof AssetApiSearchAssets
     */
    readonly deviceAssetId?: string

    /**
     *
     * @type {string}
     * @memberof AssetApiSearchAssets
     */
    readonly deviceId?: string

    /**
     *
     * @type {string}
     * @memberof AssetApiSearchAssets
     */
    readonly checksum?: string

    /**
     *
     * @type {boolean}
     * @memberof AssetApiSearchAssets
     */
    readonly isArchived?: boolean

    /**
     *
     * @type {boolean}
     * @memberof AssetApiSearchAssets
     */
    readonly isEncoded?: boolean

    /**
     *
     * @type {boolean}
     * @memberof AssetApiSearchAssets
     */
    readonly isExternal?: boolean

    /**
     *
     * @type {boolean}
     * @memberof AssetApiSearchAssets
     */
    readonly isFavorite?: boolean

    /**
     *
     * @type {boolean}
     * @memberof AssetApiSearchAssets
     */
    readonly isMotion?: boolean

    /**
     *
     * @type {boolean}
     * @memberof AssetApiSearchAssets
     */
    readonly isOffline?: boolean

    /**
     *
     * @type {boolean}
     * @memberof AssetApiSearchAssets
     */
    readonly isReadOnly?: boolean

    /**
     *
     * @type {boolean}
     * @memberof AssetApiSearchAssets
     */
    readonly isVisible?: boolean

    /**
     *
     * @type {boolean}
     * @memberof AssetApiSearchAssets
     */
    readonly withDeleted?: boolean

    /**
     *
     * @type {boolean}
     * @memberof AssetApiSearchAssets
     */
    readonly withStacked?: boolean

    /**
     *
     * @type {boolean}
     * @memberof AssetApiSearchAssets
     */
    readonly withExif?: boolean

    /**
     *
     * @type {boolean}
     * @memberof AssetApiSearchAssets
     */
    readonly withPeople?: boolean

    /**
     *
     * @type {string}
     * @memberof AssetApiSearchAssets
     */
    readonly createdBefore?: string

    /**
     *
     * @type {string}
     * @memberof AssetApiSearchAssets
     */
    readonly createdAfter?: string

    /**
     *
     * @type {string}
     * @memberof AssetApiSearchAssets
     */
    readonly updatedBefore?: string

    /**
     *
     * @type {string}
     * @memberof AssetApiSearchAssets
     */
    readonly updatedAfter?: string

    /**
     *
     * @type {string}
     * @memberof AssetApiSearchAssets
     */
    readonly trashedBefore?: string

    /**
     *
     * @type {string}
     * @memberof AssetApiSearchAssets
     */
    readonly trashedAfter?: string

    /**
     *
     * @type {string}
     * @memberof AssetApiSearchAssets
     */
    readonly takenBefore?: string

    /**
     *
     * @type {string}
     * @memberof AssetApiSearchAssets
     */
    readonly takenAfter?: string

    /**
     *
     * @type {string}
     * @memberof AssetApiSearchAssets
     */
    readonly originalFileName?: string

    /**
     *
     * @type {string}
     * @memberof AssetApiSearchAssets
     */
    readonly originalPath?: string

    /**
     *
     * @type {string}
     * @memberof AssetApiSearchAssets
     */
    readonly resizePath?: string

    /**
     *
     * @type {string}
     * @memberof AssetApiSearchAssets
     */
    readonly webpPath?: string

    /**
     *
     * @type {string}
     * @memberof AssetApiSearchAssets
     */
    readonly encodedVideoPath?: string

    /**
     *
     * @type {string}
     * @memberof AssetApiSearchAssets
     */
    readonly city?: string

    /**
     *
     * @type {string}
     * @memberof AssetApiSearchAssets
     */
    readonly state?: string

    /**
     *
     * @type {string}
     * @memberof AssetApiSearchAssets
     */
    readonly country?: string

    /**
     *
     * @type {string}
     * @memberof AssetApiSearchAssets
     */
    readonly make?: string

    /**
     *
     * @type {string}
     * @memberof AssetApiSearchAssets
     */
    readonly model?: string

    /**
     *
     * @type {string}
     * @memberof AssetApiSearchAssets
     */
    readonly lensModel?: string

    /**
     *
     * @type {number}
     * @memberof AssetApiSearchAssets
     */
    readonly page?: number

    /**
     *
     * @type {number}
     * @memberof AssetApiSearchAssets
     */
    readonly size?: number
}

/**
 * Request parameters for serveFile operation in AssetApi.
 * @export
 * @interface AssetApiServeFileRequest
 */
export interface AssetApiServeFileRequest {
    /**
     *
     * @type {string}
     * @memberof AssetApiServeFile
     */
    readonly id: string

    /**
     *
     * @type {boolean}
     * @memberof AssetApiServeFile
     */
    readonly isThumb?: boolean

    /**
     *
     * @type {boolean}
     * @memberof AssetApiServeFile
     */
    readonly isWeb?: boolean

    /**
     *
     * @type {string}
     * @memberof AssetApiServeFile
     */
    readonly key?: string
}

/**
 * Request parameters for updateAsset operation in AssetApi.
 * @export
 * @interface AssetApiUpdateAssetRequest
 */
export interface AssetApiUpdateAssetRequest {
    /**
     *
     * @type {string}
     * @memberof AssetApiUpdateAsset
     */
    readonly id: string

    /**
     *
     * @type {UpdateAssetDto}
     * @memberof AssetApiUpdateAsset
     */
    readonly updateAssetDto: UpdateAssetDto
}

/**
 * Request parameters for updateAssets operation in AssetApi.
 * @export
 * @interface AssetApiUpdateAssetsRequest
 */
export interface AssetApiUpdateAssetsRequest {
    /**
     *
     * @type {AssetBulkUpdateDto}
     * @memberof AssetApiUpdateAssets
     */
    readonly assetBulkUpdateDto: AssetBulkUpdateDto
}

/**
 * Request parameters for updateStackParent operation in AssetApi.
 * @export
 * @interface AssetApiUpdateStackParentRequest
 */
export interface AssetApiUpdateStackParentRequest {
    /**
     *
     * @type {UpdateStackParentDto}
     * @memberof AssetApiUpdateStackParent
     */
    readonly updateStackParentDto: UpdateStackParentDto
}

/**
 * Request parameters for uploadFile operation in AssetApi.
 * @export
 * @interface AssetApiUploadFileRequest
 */
export interface AssetApiUploadFileRequest {
    /**
     *
     * @type {File}
     * @memberof AssetApiUploadFile
     */
    readonly assetData: File

    /**
     *
     * @type {string}
     * @memberof AssetApiUploadFile
     */
    readonly deviceAssetId: string

    /**
     *
     * @type {string}
     * @memberof AssetApiUploadFile
     */
    readonly deviceId: string

    /**
     *
     * @type {string}
     * @memberof AssetApiUploadFile
     */
    readonly fileCreatedAt: string

    /**
     *
     * @type {string}
     * @memberof AssetApiUploadFile
     */
    readonly fileModifiedAt: string

    /**
     *
     * @type {string}
     * @memberof AssetApiUploadFile
     */
    readonly key?: string

    /**
     *
     * @type {string}
     * @memberof AssetApiUploadFile
     */
    readonly duration?: string

    /**
     *
     * @type {boolean}
     * @memberof AssetApiUploadFile
     */
    readonly isArchived?: boolean

    /**
     *
     * @type {boolean}
     * @memberof AssetApiUploadFile
     */
    readonly isExternal?: boolean

    /**
     *
     * @type {boolean}
     * @memberof AssetApiUploadFile
     */
    readonly isFavorite?: boolean

    /**
     *
     * @type {boolean}
     * @memberof AssetApiUploadFile
     */
    readonly isOffline?: boolean

    /**
     *
     * @type {boolean}
     * @memberof AssetApiUploadFile
     */
    readonly isReadOnly?: boolean

    /**
     *
     * @type {boolean}
     * @memberof AssetApiUploadFile
     */
    readonly isVisible?: boolean

    /**
     *
     * @type {string}
     * @memberof AssetApiUploadFile
     */
    readonly libraryId?: string

    /**
     *
     * @type {File}
     * @memberof AssetApiUploadFile
     */
    readonly livePhotoData?: File

    /**
     *
     * @type {File}
     * @memberof AssetApiUploadFile
     */
    readonly sidecarData?: File
}

/**
 * AssetApi - object-oriented interface
 * @export
 * @class AssetApi
 * @extends {BaseAPI}
 */
export class AssetApi extends BaseAPI {
    /**
     * Checks if assets exist by checksums
     * @param {AssetApiCheckBulkUploadRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetApi
     */
    public checkBulkUpload(requestParameters: AssetApiCheckBulkUploadRequest, options?: AxiosRequestConfig) {
        return AssetApiFp(this.configuration).checkBulkUpload(requestParameters.assetBulkUploadCheckDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Checks if multiple assets exist on the server and returns all existing - used by background backup
     * @param {AssetApiCheckExistingAssetsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetApi
     */
    public checkExistingAssets(requestParameters: AssetApiCheckExistingAssetsRequest, options?: AxiosRequestConfig) {
        return AssetApiFp(this.configuration).checkExistingAssets(requestParameters.checkExistingAssetsDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {AssetApiDeleteAssetsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetApi
     */
    public deleteAssets(requestParameters: AssetApiDeleteAssetsRequest, options?: AxiosRequestConfig) {
        return AssetApiFp(this.configuration).deleteAssets(requestParameters.assetBulkDeleteDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {AssetApiDownloadArchiveRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetApi
     */
    public downloadArchive(requestParameters: AssetApiDownloadArchiveRequest, options?: AxiosRequestConfig) {
        return AssetApiFp(this.configuration).downloadArchive(requestParameters.assetIdsDto, requestParameters.key, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {AssetApiDownloadFileRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetApi
     */
    public downloadFile(requestParameters: AssetApiDownloadFileRequest, options?: AxiosRequestConfig) {
        return AssetApiFp(this.configuration).downloadFile(requestParameters.id, requestParameters.key, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetApi
     */
    public emptyTrash(options?: AxiosRequestConfig) {
        return AssetApiFp(this.configuration).emptyTrash(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get all AssetEntity belong to the user
     * @param {AssetApiGetAllAssetsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetApi
     */
    public getAllAssets(requestParameters: AssetApiGetAllAssetsRequest = {}, options?: AxiosRequestConfig) {
        return AssetApiFp(this.configuration).getAllAssets(requestParameters.skip, requestParameters.take, requestParameters.userId, requestParameters.isFavorite, requestParameters.isArchived, requestParameters.updatedAfter, requestParameters.updatedBefore, requestParameters.ifNoneMatch, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get all asset of a device that are in the database, ID only.
     * @param {AssetApiGetAllUserAssetsByDeviceIdRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetApi
     */
    public getAllUserAssetsByDeviceId(requestParameters: AssetApiGetAllUserAssetsByDeviceIdRequest, options?: AxiosRequestConfig) {
        return AssetApiFp(this.configuration).getAllUserAssetsByDeviceId(requestParameters.deviceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a single asset\'s information
     * @param {AssetApiGetAssetByIdRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetApi
     */
    public getAssetById(requestParameters: AssetApiGetAssetByIdRequest, options?: AxiosRequestConfig) {
        return AssetApiFp(this.configuration).getAssetById(requestParameters.id, requestParameters.key, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetApi
     */
    public getAssetSearchTerms(options?: AxiosRequestConfig) {
        return AssetApiFp(this.configuration).getAssetSearchTerms(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {AssetApiGetAssetStatisticsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetApi
     */
    public getAssetStatistics(requestParameters: AssetApiGetAssetStatisticsRequest = {}, options?: AxiosRequestConfig) {
        return AssetApiFp(this.configuration).getAssetStatistics(requestParameters.isArchived, requestParameters.isFavorite, requestParameters.isTrashed, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {AssetApiGetAssetThumbnailRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetApi
     */
    public getAssetThumbnail(requestParameters: AssetApiGetAssetThumbnailRequest, options?: AxiosRequestConfig) {
        return AssetApiFp(this.configuration).getAssetThumbnail(requestParameters.id, requestParameters.format, requestParameters.key, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetApi
     */
    public getCuratedLocations(options?: AxiosRequestConfig) {
        return AssetApiFp(this.configuration).getCuratedLocations(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetApi
     */
    public getCuratedObjects(options?: AxiosRequestConfig) {
        return AssetApiFp(this.configuration).getCuratedObjects(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {AssetApiGetDownloadInfoRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetApi
     */
    public getDownloadInfo(requestParameters: AssetApiGetDownloadInfoRequest, options?: AxiosRequestConfig) {
        return AssetApiFp(this.configuration).getDownloadInfo(requestParameters.downloadInfoDto, requestParameters.key, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {AssetApiGetMapMarkersRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetApi
     */
    public getMapMarkers(requestParameters: AssetApiGetMapMarkersRequest = {}, options?: AxiosRequestConfig) {
        return AssetApiFp(this.configuration).getMapMarkers(requestParameters.isArchived, requestParameters.isFavorite, requestParameters.fileCreatedAfter, requestParameters.fileCreatedBefore, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {AssetApiGetMemoryLaneRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetApi
     */
    public getMemoryLane(requestParameters: AssetApiGetMemoryLaneRequest, options?: AxiosRequestConfig) {
        return AssetApiFp(this.configuration).getMemoryLane(requestParameters.day, requestParameters.month, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {AssetApiGetRandomRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetApi
     */
    public getRandom(requestParameters: AssetApiGetRandomRequest = {}, options?: AxiosRequestConfig) {
        return AssetApiFp(this.configuration).getRandom(requestParameters.count, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {AssetApiGetTimeBucketRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetApi
     */
    public getTimeBucket(requestParameters: AssetApiGetTimeBucketRequest, options?: AxiosRequestConfig) {
        return AssetApiFp(this.configuration).getTimeBucket(requestParameters.size, requestParameters.timeBucket, requestParameters.userId, requestParameters.albumId, requestParameters.personId, requestParameters.isArchived, requestParameters.isFavorite, requestParameters.isTrashed, requestParameters.withStacked, requestParameters.withPartners, requestParameters.key, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {AssetApiGetTimeBucketsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetApi
     */
    public getTimeBuckets(requestParameters: AssetApiGetTimeBucketsRequest, options?: AxiosRequestConfig) {
        return AssetApiFp(this.configuration).getTimeBuckets(requestParameters.size, requestParameters.userId, requestParameters.albumId, requestParameters.personId, requestParameters.isArchived, requestParameters.isFavorite, requestParameters.isTrashed, requestParameters.withStacked, requestParameters.withPartners, requestParameters.key, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary Use /asset/device/:deviceId instead - Remove in 1.92 release
     * @param {AssetApiGetUserAssetsByDeviceIdRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof AssetApi
     */
    public getUserAssetsByDeviceId(requestParameters: AssetApiGetUserAssetsByDeviceIdRequest, options?: AxiosRequestConfig) {
        return AssetApiFp(this.configuration).getUserAssetsByDeviceId(requestParameters.deviceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {AssetApiRestoreAssetsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetApi
     */
    public restoreAssets(requestParameters: AssetApiRestoreAssetsRequest, options?: AxiosRequestConfig) {
        return AssetApiFp(this.configuration).restoreAssets(requestParameters.bulkIdsDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetApi
     */
    public restoreTrash(options?: AxiosRequestConfig) {
        return AssetApiFp(this.configuration).restoreTrash(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {AssetApiRunAssetJobsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetApi
     */
    public runAssetJobs(requestParameters: AssetApiRunAssetJobsRequest, options?: AxiosRequestConfig) {
        return AssetApiFp(this.configuration).runAssetJobs(requestParameters.assetJobsDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {AssetApiSearchAssetsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetApi
     */
    public searchAssets(requestParameters: AssetApiSearchAssetsRequest = {}, options?: AxiosRequestConfig) {
        return AssetApiFp(this.configuration).searchAssets(requestParameters.id, requestParameters.libraryId, requestParameters.type, requestParameters.order, requestParameters.deviceAssetId, requestParameters.deviceId, requestParameters.checksum, requestParameters.isArchived, requestParameters.isEncoded, requestParameters.isExternal, requestParameters.isFavorite, requestParameters.isMotion, requestParameters.isOffline, requestParameters.isReadOnly, requestParameters.isVisible, requestParameters.withDeleted, requestParameters.withStacked, requestParameters.withExif, requestParameters.withPeople, requestParameters.createdBefore, requestParameters.createdAfter, requestParameters.updatedBefore, requestParameters.updatedAfter, requestParameters.trashedBefore, requestParameters.trashedAfter, requestParameters.takenBefore, requestParameters.takenAfter, requestParameters.originalFileName, requestParameters.originalPath, requestParameters.resizePath, requestParameters.webpPath, requestParameters.encodedVideoPath, requestParameters.city, requestParameters.state, requestParameters.country, requestParameters.make, requestParameters.model, requestParameters.lensModel, requestParameters.page, requestParameters.size, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {AssetApiServeFileRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetApi
     */
    public serveFile(requestParameters: AssetApiServeFileRequest, options?: AxiosRequestConfig) {
        return AssetApiFp(this.configuration).serveFile(requestParameters.id, requestParameters.isThumb, requestParameters.isWeb, requestParameters.key, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {AssetApiUpdateAssetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetApi
     */
    public updateAsset(requestParameters: AssetApiUpdateAssetRequest, options?: AxiosRequestConfig) {
        return AssetApiFp(this.configuration).updateAsset(requestParameters.id, requestParameters.updateAssetDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {AssetApiUpdateAssetsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetApi
     */
    public updateAssets(requestParameters: AssetApiUpdateAssetsRequest, options?: AxiosRequestConfig) {
        return AssetApiFp(this.configuration).updateAssets(requestParameters.assetBulkUpdateDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {AssetApiUpdateStackParentRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetApi
     */
    public updateStackParent(requestParameters: AssetApiUpdateStackParentRequest, options?: AxiosRequestConfig) {
        return AssetApiFp(this.configuration).updateStackParent(requestParameters.updateStackParentDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {AssetApiUploadFileRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetApi
     */
    public uploadFile(requestParameters: AssetApiUploadFileRequest, options?: AxiosRequestConfig) {
        return AssetApiFp(this.configuration).uploadFile(requestParameters.assetData, requestParameters.deviceAssetId, requestParameters.deviceId, requestParameters.fileCreatedAt, requestParameters.fileModifiedAt, requestParameters.key, requestParameters.duration, requestParameters.isArchived, requestParameters.isExternal, requestParameters.isFavorite, requestParameters.isOffline, requestParameters.isReadOnly, requestParameters.isVisible, requestParameters.libraryId, requestParameters.livePhotoData, requestParameters.sidecarData, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * AuditApi - axios parameter creator
 * @export
 */
export const AuditApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *
         * @param {FileReportFixDto} fileReportFixDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fixAuditFiles: async (fileReportFixDto: FileReportFixDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'fileReportFixDto' is not null or undefined
            assertParamExists('fixAuditFiles', 'fileReportFixDto', fileReportFixDto)
            const localVarPath = `/audit/file-report/fix`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookie required

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(fileReportFixDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {EntityType} entityType
         * @param {string} after
         * @param {string} [userId]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAuditDeletes: async (entityType: EntityType, after: string, userId?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'entityType' is not null or undefined
            assertParamExists('getAuditDeletes', 'entityType', entityType)
            // verify required parameter 'after' is not null or undefined
            assertParamExists('getAuditDeletes', 'after', after)
            const localVarPath = `/audit/deletes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookie required

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (entityType !== undefined) {
                localVarQueryParameter['entityType'] = entityType;
            }

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (after !== undefined) {
                localVarQueryParameter['after'] = (after as any instanceof Date) ?
                    (after as any).toISOString() :
                    after;
            }


            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAuditFiles: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/audit/file-report`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookie required

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {FileChecksumDto} fileChecksumDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFileChecksums: async (fileChecksumDto: FileChecksumDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'fileChecksumDto' is not null or undefined
            assertParamExists('getFileChecksums', 'fileChecksumDto', fileChecksumDto)
            const localVarPath = `/audit/file-report/checksum`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookie required

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(fileChecksumDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuditApi - functional programming interface
 * @export
 */
export const AuditApiFp = function (configuration?: Configuration) {
    const localVarAxiosParamCreator = AuditApiAxiosParamCreator(configuration)
    return {
        /**
         *
         * @param {FileReportFixDto} fileReportFixDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async fixAuditFiles(fileReportFixDto: FileReportFixDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.fixAuditFiles(fileReportFixDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {EntityType} entityType
         * @param {string} after
         * @param {string} [userId]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAuditDeletes(entityType: EntityType, after: string, userId?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuditDeletesResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAuditDeletes(entityType, after, userId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAuditFiles(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FileReportDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAuditFiles(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {FileChecksumDto} fileChecksumDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFileChecksums(fileChecksumDto: FileChecksumDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<FileChecksumResponseDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFileChecksums(fileChecksumDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AuditApi - factory interface
 * @export
 */
export const AuditApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AuditApiFp(configuration)
    return {
        /**
         *
         * @param {AuditApiFixAuditFilesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fixAuditFiles(requestParameters: AuditApiFixAuditFilesRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.fixAuditFiles(requestParameters.fileReportFixDto, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {AuditApiGetAuditDeletesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAuditDeletes(requestParameters: AuditApiGetAuditDeletesRequest, options?: AxiosRequestConfig): AxiosPromise<AuditDeletesResponseDto> {
            return localVarFp.getAuditDeletes(requestParameters.entityType, requestParameters.after, requestParameters.userId, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAuditFiles(options?: AxiosRequestConfig): AxiosPromise<FileReportDto> {
            return localVarFp.getAuditFiles(options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {AuditApiGetFileChecksumsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFileChecksums(requestParameters: AuditApiGetFileChecksumsRequest, options?: AxiosRequestConfig): AxiosPromise<Array<FileChecksumResponseDto>> {
            return localVarFp.getFileChecksums(requestParameters.fileChecksumDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for fixAuditFiles operation in AuditApi.
 * @export
 * @interface AuditApiFixAuditFilesRequest
 */
export interface AuditApiFixAuditFilesRequest {
    /**
     *
     * @type {FileReportFixDto}
     * @memberof AuditApiFixAuditFiles
     */
    readonly fileReportFixDto: FileReportFixDto
}

/**
 * Request parameters for getAuditDeletes operation in AuditApi.
 * @export
 * @interface AuditApiGetAuditDeletesRequest
 */
export interface AuditApiGetAuditDeletesRequest {
    /**
     *
     * @type {EntityType}
     * @memberof AuditApiGetAuditDeletes
     */
    readonly entityType: EntityType

    /**
     *
     * @type {string}
     * @memberof AuditApiGetAuditDeletes
     */
    readonly after: string

    /**
     *
     * @type {string}
     * @memberof AuditApiGetAuditDeletes
     */
    readonly userId?: string
}

/**
 * Request parameters for getFileChecksums operation in AuditApi.
 * @export
 * @interface AuditApiGetFileChecksumsRequest
 */
export interface AuditApiGetFileChecksumsRequest {
    /**
     *
     * @type {FileChecksumDto}
     * @memberof AuditApiGetFileChecksums
     */
    readonly fileChecksumDto: FileChecksumDto
}

/**
 * AuditApi - object-oriented interface
 * @export
 * @class AuditApi
 * @extends {BaseAPI}
 */
export class AuditApi extends BaseAPI {
    /**
     *
     * @param {AuditApiFixAuditFilesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuditApi
     */
    public fixAuditFiles(requestParameters: AuditApiFixAuditFilesRequest, options?: AxiosRequestConfig) {
        return AuditApiFp(this.configuration).fixAuditFiles(requestParameters.fileReportFixDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {AuditApiGetAuditDeletesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuditApi
     */
    public getAuditDeletes(requestParameters: AuditApiGetAuditDeletesRequest, options?: AxiosRequestConfig) {
        return AuditApiFp(this.configuration).getAuditDeletes(requestParameters.entityType, requestParameters.after, requestParameters.userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuditApi
     */
    public getAuditFiles(options?: AxiosRequestConfig) {
        return AuditApiFp(this.configuration).getAuditFiles(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {AuditApiGetFileChecksumsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuditApi
     */
    public getFileChecksums(requestParameters: AuditApiGetFileChecksumsRequest, options?: AxiosRequestConfig) {
        return AuditApiFp(this.configuration).getFileChecksums(requestParameters.fileChecksumDto, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * AuthenticationApi - axios parameter creator
 * @export
 */
export const AuthenticationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *
         * @param {ChangePasswordDto} changePasswordDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changePassword: async (changePasswordDto: ChangePasswordDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'changePasswordDto' is not null or undefined
            assertParamExists('changePassword', 'changePasswordDto', changePasswordDto)
            const localVarPath = `/auth/change-password`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookie required

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(changePasswordDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAuthDevices: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth/devices`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookie required

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {LoginCredentialDto} loginCredentialDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        login: async (loginCredentialDto: LoginCredentialDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'loginCredentialDto' is not null or undefined
            assertParamExists('login', 'loginCredentialDto', loginCredentialDto)
            const localVarPath = `/auth/login`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(loginCredentialDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logout: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth/logout`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookie required

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logoutAuthDevice: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('logoutAuthDevice', 'id', id)
            const localVarPath = `/auth/devices/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookie required

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logoutAuthDevices: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth/devices`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookie required

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {SignUpDto} signUpDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        signUpAdmin: async (signUpDto: SignUpDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'signUpDto' is not null or undefined
            assertParamExists('signUpAdmin', 'signUpDto', signUpDto)
            const localVarPath = `/auth/admin-sign-up`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(signUpDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validateAccessToken: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth/validateToken`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookie required

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuthenticationApi - functional programming interface
 * @export
 */
export const AuthenticationApiFp = function (configuration?: Configuration) {
    const localVarAxiosParamCreator = AuthenticationApiAxiosParamCreator(configuration)
    return {
        /**
         *
         * @param {ChangePasswordDto} changePasswordDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async changePassword(changePasswordDto: ChangePasswordDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.changePassword(changePasswordDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAuthDevices(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AuthDeviceResponseDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAuthDevices(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {LoginCredentialDto} loginCredentialDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async login(loginCredentialDto: LoginCredentialDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LoginResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.login(loginCredentialDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async logout(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LogoutResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.logout(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async logoutAuthDevice(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.logoutAuthDevice(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async logoutAuthDevices(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.logoutAuthDevices(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {SignUpDto} signUpDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async signUpAdmin(signUpDto: SignUpDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.signUpAdmin(signUpDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async validateAccessToken(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ValidateAccessTokenResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.validateAccessToken(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AuthenticationApi - factory interface
 * @export
 */
export const AuthenticationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AuthenticationApiFp(configuration)
    return {
        /**
         *
         * @param {AuthenticationApiChangePasswordRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changePassword(requestParameters: AuthenticationApiChangePasswordRequest, options?: AxiosRequestConfig): AxiosPromise<UserResponseDto> {
            return localVarFp.changePassword(requestParameters.changePasswordDto, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAuthDevices(options?: AxiosRequestConfig): AxiosPromise<Array<AuthDeviceResponseDto>> {
            return localVarFp.getAuthDevices(options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {AuthenticationApiLoginRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        login(requestParameters: AuthenticationApiLoginRequest, options?: AxiosRequestConfig): AxiosPromise<LoginResponseDto> {
            return localVarFp.login(requestParameters.loginCredentialDto, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logout(options?: AxiosRequestConfig): AxiosPromise<LogoutResponseDto> {
            return localVarFp.logout(options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {AuthenticationApiLogoutAuthDeviceRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logoutAuthDevice(requestParameters: AuthenticationApiLogoutAuthDeviceRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.logoutAuthDevice(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logoutAuthDevices(options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.logoutAuthDevices(options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {AuthenticationApiSignUpAdminRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        signUpAdmin(requestParameters: AuthenticationApiSignUpAdminRequest, options?: AxiosRequestConfig): AxiosPromise<UserResponseDto> {
            return localVarFp.signUpAdmin(requestParameters.signUpDto, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validateAccessToken(options?: AxiosRequestConfig): AxiosPromise<ValidateAccessTokenResponseDto> {
            return localVarFp.validateAccessToken(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for changePassword operation in AuthenticationApi.
 * @export
 * @interface AuthenticationApiChangePasswordRequest
 */
export interface AuthenticationApiChangePasswordRequest {
    /**
     *
     * @type {ChangePasswordDto}
     * @memberof AuthenticationApiChangePassword
     */
    readonly changePasswordDto: ChangePasswordDto
}

/**
 * Request parameters for login operation in AuthenticationApi.
 * @export
 * @interface AuthenticationApiLoginRequest
 */
export interface AuthenticationApiLoginRequest {
    /**
     *
     * @type {LoginCredentialDto}
     * @memberof AuthenticationApiLogin
     */
    readonly loginCredentialDto: LoginCredentialDto
}

/**
 * Request parameters for logoutAuthDevice operation in AuthenticationApi.
 * @export
 * @interface AuthenticationApiLogoutAuthDeviceRequest
 */
export interface AuthenticationApiLogoutAuthDeviceRequest {
    /**
     *
     * @type {string}
     * @memberof AuthenticationApiLogoutAuthDevice
     */
    readonly id: string
}

/**
 * Request parameters for signUpAdmin operation in AuthenticationApi.
 * @export
 * @interface AuthenticationApiSignUpAdminRequest
 */
export interface AuthenticationApiSignUpAdminRequest {
    /**
     *
     * @type {SignUpDto}
     * @memberof AuthenticationApiSignUpAdmin
     */
    readonly signUpDto: SignUpDto
}

/**
 * AuthenticationApi - object-oriented interface
 * @export
 * @class AuthenticationApi
 * @extends {BaseAPI}
 */
export class AuthenticationApi extends BaseAPI {
    /**
     *
     * @param {AuthenticationApiChangePasswordRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    public changePassword(requestParameters: AuthenticationApiChangePasswordRequest, options?: AxiosRequestConfig) {
        return AuthenticationApiFp(this.configuration).changePassword(requestParameters.changePasswordDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    public getAuthDevices(options?: AxiosRequestConfig) {
        return AuthenticationApiFp(this.configuration).getAuthDevices(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {AuthenticationApiLoginRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    public login(requestParameters: AuthenticationApiLoginRequest, options?: AxiosRequestConfig) {
        return AuthenticationApiFp(this.configuration).login(requestParameters.loginCredentialDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    public logout(options?: AxiosRequestConfig) {
        return AuthenticationApiFp(this.configuration).logout(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {AuthenticationApiLogoutAuthDeviceRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    public logoutAuthDevice(requestParameters: AuthenticationApiLogoutAuthDeviceRequest, options?: AxiosRequestConfig) {
        return AuthenticationApiFp(this.configuration).logoutAuthDevice(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    public logoutAuthDevices(options?: AxiosRequestConfig) {
        return AuthenticationApiFp(this.configuration).logoutAuthDevices(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {AuthenticationApiSignUpAdminRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    public signUpAdmin(requestParameters: AuthenticationApiSignUpAdminRequest, options?: AxiosRequestConfig) {
        return AuthenticationApiFp(this.configuration).signUpAdmin(requestParameters.signUpDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    public validateAccessToken(options?: AxiosRequestConfig) {
        return AuthenticationApiFp(this.configuration).validateAccessToken(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * FaceApi - axios parameter creator
 * @export
 */
export const FaceApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFaces: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getFaces', 'id', id)
            const localVarPath = `/face`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookie required

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }


            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {string} id
         * @param {FaceDto} faceDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reassignFacesById: async (id: string, faceDto: FaceDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('reassignFacesById', 'id', id)
            // verify required parameter 'faceDto' is not null or undefined
            assertParamExists('reassignFacesById', 'faceDto', faceDto)
            const localVarPath = `/face/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookie required

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(faceDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * FaceApi - functional programming interface
 * @export
 */
export const FaceApiFp = function (configuration?: Configuration) {
    const localVarAxiosParamCreator = FaceApiAxiosParamCreator(configuration)
    return {
        /**
         *
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFaces(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AssetFaceResponseDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFaces(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {string} id
         * @param {FaceDto} faceDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async reassignFacesById(id: string, faceDto: FaceDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PersonResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.reassignFacesById(id, faceDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * FaceApi - factory interface
 * @export
 */
export const FaceApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = FaceApiFp(configuration)
    return {
        /**
         *
         * @param {FaceApiGetFacesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFaces(requestParameters: FaceApiGetFacesRequest, options?: AxiosRequestConfig): AxiosPromise<Array<AssetFaceResponseDto>> {
            return localVarFp.getFaces(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {FaceApiReassignFacesByIdRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reassignFacesById(requestParameters: FaceApiReassignFacesByIdRequest, options?: AxiosRequestConfig): AxiosPromise<PersonResponseDto> {
            return localVarFp.reassignFacesById(requestParameters.id, requestParameters.faceDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for getFaces operation in FaceApi.
 * @export
 * @interface FaceApiGetFacesRequest
 */
export interface FaceApiGetFacesRequest {
    /**
     *
     * @type {string}
     * @memberof FaceApiGetFaces
     */
    readonly id: string
}

/**
 * Request parameters for reassignFacesById operation in FaceApi.
 * @export
 * @interface FaceApiReassignFacesByIdRequest
 */
export interface FaceApiReassignFacesByIdRequest {
    /**
     *
     * @type {string}
     * @memberof FaceApiReassignFacesById
     */
    readonly id: string

    /**
     *
     * @type {FaceDto}
     * @memberof FaceApiReassignFacesById
     */
    readonly faceDto: FaceDto
}

/**
 * FaceApi - object-oriented interface
 * @export
 * @class FaceApi
 * @extends {BaseAPI}
 */
export class FaceApi extends BaseAPI {
    /**
     *
     * @param {FaceApiGetFacesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FaceApi
     */
    public getFaces(requestParameters: FaceApiGetFacesRequest, options?: AxiosRequestConfig) {
        return FaceApiFp(this.configuration).getFaces(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {FaceApiReassignFacesByIdRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FaceApi
     */
    public reassignFacesById(requestParameters: FaceApiReassignFacesByIdRequest, options?: AxiosRequestConfig) {
        return FaceApiFp(this.configuration).reassignFacesById(requestParameters.id, requestParameters.faceDto, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * JobApi - axios parameter creator
 * @export
 */
export const JobApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllJobsStatus: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/jobs`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookie required

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {JobName} id
         * @param {JobCommandDto} jobCommandDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendJobCommand: async (id: JobName, jobCommandDto: JobCommandDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('sendJobCommand', 'id', id)
            // verify required parameter 'jobCommandDto' is not null or undefined
            assertParamExists('sendJobCommand', 'jobCommandDto', jobCommandDto)
            const localVarPath = `/jobs/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookie required

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(jobCommandDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * JobApi - functional programming interface
 * @export
 */
export const JobApiFp = function (configuration?: Configuration) {
    const localVarAxiosParamCreator = JobApiAxiosParamCreator(configuration)
    return {
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllJobsStatus(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AllJobStatusResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllJobsStatus(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {JobName} id
         * @param {JobCommandDto} jobCommandDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sendJobCommand(id: JobName, jobCommandDto: JobCommandDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<JobStatusDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sendJobCommand(id, jobCommandDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * JobApi - factory interface
 * @export
 */
export const JobApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = JobApiFp(configuration)
    return {
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllJobsStatus(options?: AxiosRequestConfig): AxiosPromise<AllJobStatusResponseDto> {
            return localVarFp.getAllJobsStatus(options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {JobApiSendJobCommandRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendJobCommand(requestParameters: JobApiSendJobCommandRequest, options?: AxiosRequestConfig): AxiosPromise<JobStatusDto> {
            return localVarFp.sendJobCommand(requestParameters.id, requestParameters.jobCommandDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for sendJobCommand operation in JobApi.
 * @export
 * @interface JobApiSendJobCommandRequest
 */
export interface JobApiSendJobCommandRequest {
    /**
     *
     * @type {JobName}
     * @memberof JobApiSendJobCommand
     */
    readonly id: JobName

    /**
     *
     * @type {JobCommandDto}
     * @memberof JobApiSendJobCommand
     */
    readonly jobCommandDto: JobCommandDto
}

/**
 * JobApi - object-oriented interface
 * @export
 * @class JobApi
 * @extends {BaseAPI}
 */
export class JobApi extends BaseAPI {
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JobApi
     */
    public getAllJobsStatus(options?: AxiosRequestConfig) {
        return JobApiFp(this.configuration).getAllJobsStatus(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {JobApiSendJobCommandRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JobApi
     */
    public sendJobCommand(requestParameters: JobApiSendJobCommandRequest, options?: AxiosRequestConfig) {
        return JobApiFp(this.configuration).sendJobCommand(requestParameters.id, requestParameters.jobCommandDto, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * LibraryApi - axios parameter creator
 * @export
 */
export const LibraryApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *
         * @param {CreateLibraryDto} createLibraryDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createLibrary: async (createLibraryDto: CreateLibraryDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createLibraryDto' is not null or undefined
            assertParamExists('createLibrary', 'createLibraryDto', createLibraryDto)
            const localVarPath = `/library`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookie required

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createLibraryDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteLibrary: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteLibrary', 'id', id)
            const localVarPath = `/library/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookie required

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLibraries: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/library`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookie required

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLibraryInfo: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getLibraryInfo', 'id', id)
            const localVarPath = `/library/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookie required

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLibraryStatistics: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getLibraryStatistics', 'id', id)
            const localVarPath = `/library/{id}/statistics`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookie required

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeOfflineFiles: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('removeOfflineFiles', 'id', id)
            const localVarPath = `/library/{id}/removeOffline`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookie required

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {string} id
         * @param {ScanLibraryDto} scanLibraryDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        scanLibrary: async (id: string, scanLibraryDto: ScanLibraryDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('scanLibrary', 'id', id)
            // verify required parameter 'scanLibraryDto' is not null or undefined
            assertParamExists('scanLibrary', 'scanLibraryDto', scanLibraryDto)
            const localVarPath = `/library/{id}/scan`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookie required

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(scanLibraryDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {string} id
         * @param {UpdateLibraryDto} updateLibraryDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateLibrary: async (id: string, updateLibraryDto: UpdateLibraryDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateLibrary', 'id', id)
            // verify required parameter 'updateLibraryDto' is not null or undefined
            assertParamExists('updateLibrary', 'updateLibraryDto', updateLibraryDto)
            const localVarPath = `/library/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookie required

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateLibraryDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * LibraryApi - functional programming interface
 * @export
 */
export const LibraryApiFp = function (configuration?: Configuration) {
    const localVarAxiosParamCreator = LibraryApiAxiosParamCreator(configuration)
    return {
        /**
         *
         * @param {CreateLibraryDto} createLibraryDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createLibrary(createLibraryDto: CreateLibraryDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LibraryResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createLibrary(createLibraryDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteLibrary(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteLibrary(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLibraries(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<LibraryResponseDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getLibraries(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLibraryInfo(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LibraryResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getLibraryInfo(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLibraryStatistics(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LibraryStatsResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getLibraryStatistics(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async removeOfflineFiles(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.removeOfflineFiles(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {string} id
         * @param {ScanLibraryDto} scanLibraryDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async scanLibrary(id: string, scanLibraryDto: ScanLibraryDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.scanLibrary(id, scanLibraryDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {string} id
         * @param {UpdateLibraryDto} updateLibraryDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateLibrary(id: string, updateLibraryDto: UpdateLibraryDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LibraryResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateLibrary(id, updateLibraryDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * LibraryApi - factory interface
 * @export
 */
export const LibraryApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = LibraryApiFp(configuration)
    return {
        /**
         *
         * @param {LibraryApiCreateLibraryRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createLibrary(requestParameters: LibraryApiCreateLibraryRequest, options?: AxiosRequestConfig): AxiosPromise<LibraryResponseDto> {
            return localVarFp.createLibrary(requestParameters.createLibraryDto, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {LibraryApiDeleteLibraryRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteLibrary(requestParameters: LibraryApiDeleteLibraryRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteLibrary(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLibraries(options?: AxiosRequestConfig): AxiosPromise<Array<LibraryResponseDto>> {
            return localVarFp.getLibraries(options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {LibraryApiGetLibraryInfoRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLibraryInfo(requestParameters: LibraryApiGetLibraryInfoRequest, options?: AxiosRequestConfig): AxiosPromise<LibraryResponseDto> {
            return localVarFp.getLibraryInfo(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {LibraryApiGetLibraryStatisticsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLibraryStatistics(requestParameters: LibraryApiGetLibraryStatisticsRequest, options?: AxiosRequestConfig): AxiosPromise<LibraryStatsResponseDto> {
            return localVarFp.getLibraryStatistics(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {LibraryApiRemoveOfflineFilesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeOfflineFiles(requestParameters: LibraryApiRemoveOfflineFilesRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.removeOfflineFiles(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {LibraryApiScanLibraryRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        scanLibrary(requestParameters: LibraryApiScanLibraryRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.scanLibrary(requestParameters.id, requestParameters.scanLibraryDto, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {LibraryApiUpdateLibraryRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateLibrary(requestParameters: LibraryApiUpdateLibraryRequest, options?: AxiosRequestConfig): AxiosPromise<LibraryResponseDto> {
            return localVarFp.updateLibrary(requestParameters.id, requestParameters.updateLibraryDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createLibrary operation in LibraryApi.
 * @export
 * @interface LibraryApiCreateLibraryRequest
 */
export interface LibraryApiCreateLibraryRequest {
    /**
     *
     * @type {CreateLibraryDto}
     * @memberof LibraryApiCreateLibrary
     */
    readonly createLibraryDto: CreateLibraryDto
}

/**
 * Request parameters for deleteLibrary operation in LibraryApi.
 * @export
 * @interface LibraryApiDeleteLibraryRequest
 */
export interface LibraryApiDeleteLibraryRequest {
    /**
     *
     * @type {string}
     * @memberof LibraryApiDeleteLibrary
     */
    readonly id: string
}

/**
 * Request parameters for getLibraryInfo operation in LibraryApi.
 * @export
 * @interface LibraryApiGetLibraryInfoRequest
 */
export interface LibraryApiGetLibraryInfoRequest {
    /**
     *
     * @type {string}
     * @memberof LibraryApiGetLibraryInfo
     */
    readonly id: string
}

/**
 * Request parameters for getLibraryStatistics operation in LibraryApi.
 * @export
 * @interface LibraryApiGetLibraryStatisticsRequest
 */
export interface LibraryApiGetLibraryStatisticsRequest {
    /**
     *
     * @type {string}
     * @memberof LibraryApiGetLibraryStatistics
     */
    readonly id: string
}

/**
 * Request parameters for removeOfflineFiles operation in LibraryApi.
 * @export
 * @interface LibraryApiRemoveOfflineFilesRequest
 */
export interface LibraryApiRemoveOfflineFilesRequest {
    /**
     *
     * @type {string}
     * @memberof LibraryApiRemoveOfflineFiles
     */
    readonly id: string
}

/**
 * Request parameters for scanLibrary operation in LibraryApi.
 * @export
 * @interface LibraryApiScanLibraryRequest
 */
export interface LibraryApiScanLibraryRequest {
    /**
     *
     * @type {string}
     * @memberof LibraryApiScanLibrary
     */
    readonly id: string

    /**
     *
     * @type {ScanLibraryDto}
     * @memberof LibraryApiScanLibrary
     */
    readonly scanLibraryDto: ScanLibraryDto
}

/**
 * Request parameters for updateLibrary operation in LibraryApi.
 * @export
 * @interface LibraryApiUpdateLibraryRequest
 */
export interface LibraryApiUpdateLibraryRequest {
    /**
     *
     * @type {string}
     * @memberof LibraryApiUpdateLibrary
     */
    readonly id: string

    /**
     *
     * @type {UpdateLibraryDto}
     * @memberof LibraryApiUpdateLibrary
     */
    readonly updateLibraryDto: UpdateLibraryDto
}

/**
 * LibraryApi - object-oriented interface
 * @export
 * @class LibraryApi
 * @extends {BaseAPI}
 */
export class LibraryApi extends BaseAPI {
    /**
     *
     * @param {LibraryApiCreateLibraryRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LibraryApi
     */
    public createLibrary(requestParameters: LibraryApiCreateLibraryRequest, options?: AxiosRequestConfig) {
        return LibraryApiFp(this.configuration).createLibrary(requestParameters.createLibraryDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {LibraryApiDeleteLibraryRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LibraryApi
     */
    public deleteLibrary(requestParameters: LibraryApiDeleteLibraryRequest, options?: AxiosRequestConfig) {
        return LibraryApiFp(this.configuration).deleteLibrary(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LibraryApi
     */
    public getLibraries(options?: AxiosRequestConfig) {
        return LibraryApiFp(this.configuration).getLibraries(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {LibraryApiGetLibraryInfoRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LibraryApi
     */
    public getLibraryInfo(requestParameters: LibraryApiGetLibraryInfoRequest, options?: AxiosRequestConfig) {
        return LibraryApiFp(this.configuration).getLibraryInfo(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {LibraryApiGetLibraryStatisticsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LibraryApi
     */
    public getLibraryStatistics(requestParameters: LibraryApiGetLibraryStatisticsRequest, options?: AxiosRequestConfig) {
        return LibraryApiFp(this.configuration).getLibraryStatistics(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {LibraryApiRemoveOfflineFilesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LibraryApi
     */
    public removeOfflineFiles(requestParameters: LibraryApiRemoveOfflineFilesRequest, options?: AxiosRequestConfig) {
        return LibraryApiFp(this.configuration).removeOfflineFiles(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {LibraryApiScanLibraryRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LibraryApi
     */
    public scanLibrary(requestParameters: LibraryApiScanLibraryRequest, options?: AxiosRequestConfig) {
        return LibraryApiFp(this.configuration).scanLibrary(requestParameters.id, requestParameters.scanLibraryDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {LibraryApiUpdateLibraryRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LibraryApi
     */
    public updateLibrary(requestParameters: LibraryApiUpdateLibraryRequest, options?: AxiosRequestConfig) {
        return LibraryApiFp(this.configuration).updateLibrary(requestParameters.id, requestParameters.updateLibraryDto, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * OAuthApi - axios parameter creator
 * @export
 */
export const OAuthApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *
         * @param {OAuthCallbackDto} oAuthCallbackDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        finishOAuth: async (oAuthCallbackDto: OAuthCallbackDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'oAuthCallbackDto' is not null or undefined
            assertParamExists('finishOAuth', 'oAuthCallbackDto', oAuthCallbackDto)
            const localVarPath = `/oauth/callback`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(oAuthCallbackDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * @deprecated use feature flags and /oauth/authorize
         * @param {OAuthConfigDto} oAuthConfigDto
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        generateOAuthConfig: async (oAuthConfigDto: OAuthConfigDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'oAuthConfigDto' is not null or undefined
            assertParamExists('generateOAuthConfig', 'oAuthConfigDto', oAuthConfigDto)
            const localVarPath = `/oauth/config`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(oAuthConfigDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {OAuthCallbackDto} oAuthCallbackDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        linkOAuthAccount: async (oAuthCallbackDto: OAuthCallbackDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'oAuthCallbackDto' is not null or undefined
            assertParamExists('linkOAuthAccount', 'oAuthCallbackDto', oAuthCallbackDto)
            const localVarPath = `/oauth/link`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookie required

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(oAuthCallbackDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        redirectOAuthToMobile: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/oauth/mobile-redirect`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {OAuthConfigDto} oAuthConfigDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        startOAuth: async (oAuthConfigDto: OAuthConfigDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'oAuthConfigDto' is not null or undefined
            assertParamExists('startOAuth', 'oAuthConfigDto', oAuthConfigDto)
            const localVarPath = `/oauth/authorize`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(oAuthConfigDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unlinkOAuthAccount: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/oauth/unlink`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookie required

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OAuthApi - functional programming interface
 * @export
 */
export const OAuthApiFp = function (configuration?: Configuration) {
    const localVarAxiosParamCreator = OAuthApiAxiosParamCreator(configuration)
    return {
        /**
         *
         * @param {OAuthCallbackDto} oAuthCallbackDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async finishOAuth(oAuthCallbackDto: OAuthCallbackDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LoginResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.finishOAuth(oAuthCallbackDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * @deprecated use feature flags and /oauth/authorize
         * @param {OAuthConfigDto} oAuthConfigDto
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async generateOAuthConfig(oAuthConfigDto: OAuthConfigDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OAuthConfigResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.generateOAuthConfig(oAuthConfigDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {OAuthCallbackDto} oAuthCallbackDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async linkOAuthAccount(oAuthCallbackDto: OAuthCallbackDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.linkOAuthAccount(oAuthCallbackDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async redirectOAuthToMobile(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.redirectOAuthToMobile(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {OAuthConfigDto} oAuthConfigDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async startOAuth(oAuthConfigDto: OAuthConfigDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OAuthAuthorizeResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.startOAuth(oAuthConfigDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async unlinkOAuthAccount(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.unlinkOAuthAccount(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * OAuthApi - factory interface
 * @export
 */
export const OAuthApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = OAuthApiFp(configuration)
    return {
        /**
         *
         * @param {OAuthApiFinishOAuthRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        finishOAuth(requestParameters: OAuthApiFinishOAuthRequest, options?: AxiosRequestConfig): AxiosPromise<LoginResponseDto> {
            return localVarFp.finishOAuth(requestParameters.oAuthCallbackDto, options).then((request) => request(axios, basePath));
        },
        /**
         * @deprecated use feature flags and /oauth/authorize
         * @param {OAuthApiGenerateOAuthConfigRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        generateOAuthConfig(requestParameters: OAuthApiGenerateOAuthConfigRequest, options?: AxiosRequestConfig): AxiosPromise<OAuthConfigResponseDto> {
            return localVarFp.generateOAuthConfig(requestParameters.oAuthConfigDto, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {OAuthApiLinkOAuthAccountRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        linkOAuthAccount(requestParameters: OAuthApiLinkOAuthAccountRequest, options?: AxiosRequestConfig): AxiosPromise<UserResponseDto> {
            return localVarFp.linkOAuthAccount(requestParameters.oAuthCallbackDto, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        redirectOAuthToMobile(options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.redirectOAuthToMobile(options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {OAuthApiStartOAuthRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        startOAuth(requestParameters: OAuthApiStartOAuthRequest, options?: AxiosRequestConfig): AxiosPromise<OAuthAuthorizeResponseDto> {
            return localVarFp.startOAuth(requestParameters.oAuthConfigDto, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unlinkOAuthAccount(options?: AxiosRequestConfig): AxiosPromise<UserResponseDto> {
            return localVarFp.unlinkOAuthAccount(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for finishOAuth operation in OAuthApi.
 * @export
 * @interface OAuthApiFinishOAuthRequest
 */
export interface OAuthApiFinishOAuthRequest {
    /**
     *
     * @type {OAuthCallbackDto}
     * @memberof OAuthApiFinishOAuth
     */
    readonly oAuthCallbackDto: OAuthCallbackDto
}

/**
 * Request parameters for generateOAuthConfig operation in OAuthApi.
 * @export
 * @interface OAuthApiGenerateOAuthConfigRequest
 */
export interface OAuthApiGenerateOAuthConfigRequest {
    /**
     *
     * @type {OAuthConfigDto}
     * @memberof OAuthApiGenerateOAuthConfig
     */
    readonly oAuthConfigDto: OAuthConfigDto
}

/**
 * Request parameters for linkOAuthAccount operation in OAuthApi.
 * @export
 * @interface OAuthApiLinkOAuthAccountRequest
 */
export interface OAuthApiLinkOAuthAccountRequest {
    /**
     *
     * @type {OAuthCallbackDto}
     * @memberof OAuthApiLinkOAuthAccount
     */
    readonly oAuthCallbackDto: OAuthCallbackDto
}

/**
 * Request parameters for startOAuth operation in OAuthApi.
 * @export
 * @interface OAuthApiStartOAuthRequest
 */
export interface OAuthApiStartOAuthRequest {
    /**
     *
     * @type {OAuthConfigDto}
     * @memberof OAuthApiStartOAuth
     */
    readonly oAuthConfigDto: OAuthConfigDto
}

/**
 * OAuthApi - object-oriented interface
 * @export
 * @class OAuthApi
 * @extends {BaseAPI}
 */
export class OAuthApi extends BaseAPI {
    /**
     *
     * @param {OAuthApiFinishOAuthRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OAuthApi
     */
    public finishOAuth(requestParameters: OAuthApiFinishOAuthRequest, options?: AxiosRequestConfig) {
        return OAuthApiFp(this.configuration).finishOAuth(requestParameters.oAuthCallbackDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * @deprecated use feature flags and /oauth/authorize
     * @param {OAuthApiGenerateOAuthConfigRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof OAuthApi
     */
    public generateOAuthConfig(requestParameters: OAuthApiGenerateOAuthConfigRequest, options?: AxiosRequestConfig) {
        return OAuthApiFp(this.configuration).generateOAuthConfig(requestParameters.oAuthConfigDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {OAuthApiLinkOAuthAccountRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OAuthApi
     */
    public linkOAuthAccount(requestParameters: OAuthApiLinkOAuthAccountRequest, options?: AxiosRequestConfig) {
        return OAuthApiFp(this.configuration).linkOAuthAccount(requestParameters.oAuthCallbackDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OAuthApi
     */
    public redirectOAuthToMobile(options?: AxiosRequestConfig) {
        return OAuthApiFp(this.configuration).redirectOAuthToMobile(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {OAuthApiStartOAuthRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OAuthApi
     */
    public startOAuth(requestParameters: OAuthApiStartOAuthRequest, options?: AxiosRequestConfig) {
        return OAuthApiFp(this.configuration).startOAuth(requestParameters.oAuthConfigDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OAuthApi
     */
    public unlinkOAuthAccount(options?: AxiosRequestConfig) {
        return OAuthApiFp(this.configuration).unlinkOAuthAccount(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * PartnerApi - axios parameter creator
 * @export
 */
export const PartnerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPartner: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('createPartner', 'id', id)
            const localVarPath = `/partner/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookie required

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {'shared-by' | 'shared-with'} direction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPartners: async (direction: 'shared-by' | 'shared-with', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'direction' is not null or undefined
            assertParamExists('getPartners', 'direction', direction)
            const localVarPath = `/partner`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookie required

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (direction !== undefined) {
                localVarQueryParameter['direction'] = direction;
            }


            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removePartner: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('removePartner', 'id', id)
            const localVarPath = `/partner/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookie required

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {string} id
         * @param {UpdatePartnerDto} updatePartnerDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePartner: async (id: string, updatePartnerDto: UpdatePartnerDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updatePartner', 'id', id)
            // verify required parameter 'updatePartnerDto' is not null or undefined
            assertParamExists('updatePartner', 'updatePartnerDto', updatePartnerDto)
            const localVarPath = `/partner/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookie required

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updatePartnerDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PartnerApi - functional programming interface
 * @export
 */
export const PartnerApiFp = function (configuration?: Configuration) {
    const localVarAxiosParamCreator = PartnerApiAxiosParamCreator(configuration)
    return {
        /**
         *
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createPartner(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PartnerResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createPartner(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {'shared-by' | 'shared-with'} direction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPartners(direction: 'shared-by' | 'shared-with', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PartnerResponseDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPartners(direction, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async removePartner(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.removePartner(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {string} id
         * @param {UpdatePartnerDto} updatePartnerDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updatePartner(id: string, updatePartnerDto: UpdatePartnerDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PartnerResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updatePartner(id, updatePartnerDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * PartnerApi - factory interface
 * @export
 */
export const PartnerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PartnerApiFp(configuration)
    return {
        /**
         *
         * @param {PartnerApiCreatePartnerRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPartner(requestParameters: PartnerApiCreatePartnerRequest, options?: AxiosRequestConfig): AxiosPromise<PartnerResponseDto> {
            return localVarFp.createPartner(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {PartnerApiGetPartnersRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPartners(requestParameters: PartnerApiGetPartnersRequest, options?: AxiosRequestConfig): AxiosPromise<Array<PartnerResponseDto>> {
            return localVarFp.getPartners(requestParameters.direction, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {PartnerApiRemovePartnerRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removePartner(requestParameters: PartnerApiRemovePartnerRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.removePartner(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {PartnerApiUpdatePartnerRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePartner(requestParameters: PartnerApiUpdatePartnerRequest, options?: AxiosRequestConfig): AxiosPromise<PartnerResponseDto> {
            return localVarFp.updatePartner(requestParameters.id, requestParameters.updatePartnerDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createPartner operation in PartnerApi.
 * @export
 * @interface PartnerApiCreatePartnerRequest
 */
export interface PartnerApiCreatePartnerRequest {
    /**
     *
     * @type {string}
     * @memberof PartnerApiCreatePartner
     */
    readonly id: string
}

/**
 * Request parameters for getPartners operation in PartnerApi.
 * @export
 * @interface PartnerApiGetPartnersRequest
 */
export interface PartnerApiGetPartnersRequest {
    /**
     *
     * @type {'shared-by' | 'shared-with'}
     * @memberof PartnerApiGetPartners
     */
    readonly direction: 'shared-by' | 'shared-with'
}

/**
 * Request parameters for removePartner operation in PartnerApi.
 * @export
 * @interface PartnerApiRemovePartnerRequest
 */
export interface PartnerApiRemovePartnerRequest {
    /**
     *
     * @type {string}
     * @memberof PartnerApiRemovePartner
     */
    readonly id: string
}

/**
 * Request parameters for updatePartner operation in PartnerApi.
 * @export
 * @interface PartnerApiUpdatePartnerRequest
 */
export interface PartnerApiUpdatePartnerRequest {
    /**
     *
     * @type {string}
     * @memberof PartnerApiUpdatePartner
     */
    readonly id: string

    /**
     *
     * @type {UpdatePartnerDto}
     * @memberof PartnerApiUpdatePartner
     */
    readonly updatePartnerDto: UpdatePartnerDto
}

/**
 * PartnerApi - object-oriented interface
 * @export
 * @class PartnerApi
 * @extends {BaseAPI}
 */
export class PartnerApi extends BaseAPI {
    /**
     *
     * @param {PartnerApiCreatePartnerRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PartnerApi
     */
    public createPartner(requestParameters: PartnerApiCreatePartnerRequest, options?: AxiosRequestConfig) {
        return PartnerApiFp(this.configuration).createPartner(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {PartnerApiGetPartnersRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PartnerApi
     */
    public getPartners(requestParameters: PartnerApiGetPartnersRequest, options?: AxiosRequestConfig) {
        return PartnerApiFp(this.configuration).getPartners(requestParameters.direction, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {PartnerApiRemovePartnerRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PartnerApi
     */
    public removePartner(requestParameters: PartnerApiRemovePartnerRequest, options?: AxiosRequestConfig) {
        return PartnerApiFp(this.configuration).removePartner(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {PartnerApiUpdatePartnerRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PartnerApi
     */
    public updatePartner(requestParameters: PartnerApiUpdatePartnerRequest, options?: AxiosRequestConfig) {
        return PartnerApiFp(this.configuration).updatePartner(requestParameters.id, requestParameters.updatePartnerDto, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * PersonApi - axios parameter creator
 * @export
 */
export const PersonApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPerson: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/person`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookie required

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {boolean} [withHidden]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllPeople: async (withHidden?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/person`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookie required

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (withHidden !== undefined) {
                localVarQueryParameter['withHidden'] = withHidden;
            }


            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPerson: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getPerson', 'id', id)
            const localVarPath = `/person/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookie required

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPersonAssets: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getPersonAssets', 'id', id)
            const localVarPath = `/person/{id}/assets`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookie required

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPersonStatistics: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getPersonStatistics', 'id', id)
            const localVarPath = `/person/{id}/statistics`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookie required

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPersonThumbnail: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getPersonThumbnail', 'id', id)
            const localVarPath = `/person/{id}/thumbnail`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookie required

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {string} id
         * @param {MergePersonDto} mergePersonDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mergePerson: async (id: string, mergePersonDto: MergePersonDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('mergePerson', 'id', id)
            // verify required parameter 'mergePersonDto' is not null or undefined
            assertParamExists('mergePerson', 'mergePersonDto', mergePersonDto)
            const localVarPath = `/person/{id}/merge`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookie required

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(mergePersonDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {string} id
         * @param {AssetFaceUpdateDto} assetFaceUpdateDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reassignFaces: async (id: string, assetFaceUpdateDto: AssetFaceUpdateDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('reassignFaces', 'id', id)
            // verify required parameter 'assetFaceUpdateDto' is not null or undefined
            assertParamExists('reassignFaces', 'assetFaceUpdateDto', assetFaceUpdateDto)
            const localVarPath = `/person/{id}/reassign`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookie required

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(assetFaceUpdateDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {PeopleUpdateDto} peopleUpdateDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePeople: async (peopleUpdateDto: PeopleUpdateDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'peopleUpdateDto' is not null or undefined
            assertParamExists('updatePeople', 'peopleUpdateDto', peopleUpdateDto)
            const localVarPath = `/person`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookie required

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(peopleUpdateDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {string} id
         * @param {PersonUpdateDto} personUpdateDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePerson: async (id: string, personUpdateDto: PersonUpdateDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updatePerson', 'id', id)
            // verify required parameter 'personUpdateDto' is not null or undefined
            assertParamExists('updatePerson', 'personUpdateDto', personUpdateDto)
            const localVarPath = `/person/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookie required

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(personUpdateDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PersonApi - functional programming interface
 * @export
 */
export const PersonApiFp = function (configuration?: Configuration) {
    const localVarAxiosParamCreator = PersonApiAxiosParamCreator(configuration)
    return {
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createPerson(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PersonResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createPerson(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {boolean} [withHidden]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllPeople(withHidden?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PeopleResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllPeople(withHidden, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPerson(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PersonResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPerson(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPersonAssets(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AssetResponseDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPersonAssets(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPersonStatistics(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PersonStatisticsResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPersonStatistics(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPersonThumbnail(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<File>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPersonThumbnail(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {string} id
         * @param {MergePersonDto} mergePersonDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async mergePerson(id: string, mergePersonDto: MergePersonDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<BulkIdResponseDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.mergePerson(id, mergePersonDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {string} id
         * @param {AssetFaceUpdateDto} assetFaceUpdateDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async reassignFaces(id: string, assetFaceUpdateDto: AssetFaceUpdateDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PersonResponseDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.reassignFaces(id, assetFaceUpdateDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {PeopleUpdateDto} peopleUpdateDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updatePeople(peopleUpdateDto: PeopleUpdateDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<BulkIdResponseDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updatePeople(peopleUpdateDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {string} id
         * @param {PersonUpdateDto} personUpdateDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updatePerson(id: string, personUpdateDto: PersonUpdateDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PersonResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updatePerson(id, personUpdateDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * PersonApi - factory interface
 * @export
 */
export const PersonApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PersonApiFp(configuration)
    return {
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPerson(options?: AxiosRequestConfig): AxiosPromise<PersonResponseDto> {
            return localVarFp.createPerson(options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {PersonApiGetAllPeopleRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllPeople(requestParameters: PersonApiGetAllPeopleRequest = {}, options?: AxiosRequestConfig): AxiosPromise<PeopleResponseDto> {
            return localVarFp.getAllPeople(requestParameters.withHidden, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {PersonApiGetPersonRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPerson(requestParameters: PersonApiGetPersonRequest, options?: AxiosRequestConfig): AxiosPromise<PersonResponseDto> {
            return localVarFp.getPerson(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {PersonApiGetPersonAssetsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPersonAssets(requestParameters: PersonApiGetPersonAssetsRequest, options?: AxiosRequestConfig): AxiosPromise<Array<AssetResponseDto>> {
            return localVarFp.getPersonAssets(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {PersonApiGetPersonStatisticsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPersonStatistics(requestParameters: PersonApiGetPersonStatisticsRequest, options?: AxiosRequestConfig): AxiosPromise<PersonStatisticsResponseDto> {
            return localVarFp.getPersonStatistics(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {PersonApiGetPersonThumbnailRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPersonThumbnail(requestParameters: PersonApiGetPersonThumbnailRequest, options?: AxiosRequestConfig): AxiosPromise<File> {
            return localVarFp.getPersonThumbnail(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {PersonApiMergePersonRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mergePerson(requestParameters: PersonApiMergePersonRequest, options?: AxiosRequestConfig): AxiosPromise<Array<BulkIdResponseDto>> {
            return localVarFp.mergePerson(requestParameters.id, requestParameters.mergePersonDto, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {PersonApiReassignFacesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reassignFaces(requestParameters: PersonApiReassignFacesRequest, options?: AxiosRequestConfig): AxiosPromise<Array<PersonResponseDto>> {
            return localVarFp.reassignFaces(requestParameters.id, requestParameters.assetFaceUpdateDto, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {PersonApiUpdatePeopleRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePeople(requestParameters: PersonApiUpdatePeopleRequest, options?: AxiosRequestConfig): AxiosPromise<Array<BulkIdResponseDto>> {
            return localVarFp.updatePeople(requestParameters.peopleUpdateDto, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {PersonApiUpdatePersonRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePerson(requestParameters: PersonApiUpdatePersonRequest, options?: AxiosRequestConfig): AxiosPromise<PersonResponseDto> {
            return localVarFp.updatePerson(requestParameters.id, requestParameters.personUpdateDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for getAllPeople operation in PersonApi.
 * @export
 * @interface PersonApiGetAllPeopleRequest
 */
export interface PersonApiGetAllPeopleRequest {
    /**
     *
     * @type {boolean}
     * @memberof PersonApiGetAllPeople
     */
    readonly withHidden?: boolean
}

/**
 * Request parameters for getPerson operation in PersonApi.
 * @export
 * @interface PersonApiGetPersonRequest
 */
export interface PersonApiGetPersonRequest {
    /**
     *
     * @type {string}
     * @memberof PersonApiGetPerson
     */
    readonly id: string
}

/**
 * Request parameters for getPersonAssets operation in PersonApi.
 * @export
 * @interface PersonApiGetPersonAssetsRequest
 */
export interface PersonApiGetPersonAssetsRequest {
    /**
     *
     * @type {string}
     * @memberof PersonApiGetPersonAssets
     */
    readonly id: string
}

/**
 * Request parameters for getPersonStatistics operation in PersonApi.
 * @export
 * @interface PersonApiGetPersonStatisticsRequest
 */
export interface PersonApiGetPersonStatisticsRequest {
    /**
     *
     * @type {string}
     * @memberof PersonApiGetPersonStatistics
     */
    readonly id: string
}

/**
 * Request parameters for getPersonThumbnail operation in PersonApi.
 * @export
 * @interface PersonApiGetPersonThumbnailRequest
 */
export interface PersonApiGetPersonThumbnailRequest {
    /**
     *
     * @type {string}
     * @memberof PersonApiGetPersonThumbnail
     */
    readonly id: string
}

/**
 * Request parameters for mergePerson operation in PersonApi.
 * @export
 * @interface PersonApiMergePersonRequest
 */
export interface PersonApiMergePersonRequest {
    /**
     *
     * @type {string}
     * @memberof PersonApiMergePerson
     */
    readonly id: string

    /**
     *
     * @type {MergePersonDto}
     * @memberof PersonApiMergePerson
     */
    readonly mergePersonDto: MergePersonDto
}

/**
 * Request parameters for reassignFaces operation in PersonApi.
 * @export
 * @interface PersonApiReassignFacesRequest
 */
export interface PersonApiReassignFacesRequest {
    /**
     *
     * @type {string}
     * @memberof PersonApiReassignFaces
     */
    readonly id: string

    /**
     *
     * @type {AssetFaceUpdateDto}
     * @memberof PersonApiReassignFaces
     */
    readonly assetFaceUpdateDto: AssetFaceUpdateDto
}

/**
 * Request parameters for updatePeople operation in PersonApi.
 * @export
 * @interface PersonApiUpdatePeopleRequest
 */
export interface PersonApiUpdatePeopleRequest {
    /**
     *
     * @type {PeopleUpdateDto}
     * @memberof PersonApiUpdatePeople
     */
    readonly peopleUpdateDto: PeopleUpdateDto
}

/**
 * Request parameters for updatePerson operation in PersonApi.
 * @export
 * @interface PersonApiUpdatePersonRequest
 */
export interface PersonApiUpdatePersonRequest {
    /**
     *
     * @type {string}
     * @memberof PersonApiUpdatePerson
     */
    readonly id: string

    /**
     *
     * @type {PersonUpdateDto}
     * @memberof PersonApiUpdatePerson
     */
    readonly personUpdateDto: PersonUpdateDto
}

/**
 * PersonApi - object-oriented interface
 * @export
 * @class PersonApi
 * @extends {BaseAPI}
 */
export class PersonApi extends BaseAPI {
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersonApi
     */
    public createPerson(options?: AxiosRequestConfig) {
        return PersonApiFp(this.configuration).createPerson(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {PersonApiGetAllPeopleRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersonApi
     */
    public getAllPeople(requestParameters: PersonApiGetAllPeopleRequest = {}, options?: AxiosRequestConfig) {
        return PersonApiFp(this.configuration).getAllPeople(requestParameters.withHidden, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {PersonApiGetPersonRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersonApi
     */
    public getPerson(requestParameters: PersonApiGetPersonRequest, options?: AxiosRequestConfig) {
        return PersonApiFp(this.configuration).getPerson(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {PersonApiGetPersonAssetsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersonApi
     */
    public getPersonAssets(requestParameters: PersonApiGetPersonAssetsRequest, options?: AxiosRequestConfig) {
        return PersonApiFp(this.configuration).getPersonAssets(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {PersonApiGetPersonStatisticsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersonApi
     */
    public getPersonStatistics(requestParameters: PersonApiGetPersonStatisticsRequest, options?: AxiosRequestConfig) {
        return PersonApiFp(this.configuration).getPersonStatistics(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {PersonApiGetPersonThumbnailRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersonApi
     */
    public getPersonThumbnail(requestParameters: PersonApiGetPersonThumbnailRequest, options?: AxiosRequestConfig) {
        return PersonApiFp(this.configuration).getPersonThumbnail(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {PersonApiMergePersonRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersonApi
     */
    public mergePerson(requestParameters: PersonApiMergePersonRequest, options?: AxiosRequestConfig) {
        return PersonApiFp(this.configuration).mergePerson(requestParameters.id, requestParameters.mergePersonDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {PersonApiReassignFacesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersonApi
     */
    public reassignFaces(requestParameters: PersonApiReassignFacesRequest, options?: AxiosRequestConfig) {
        return PersonApiFp(this.configuration).reassignFaces(requestParameters.id, requestParameters.assetFaceUpdateDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {PersonApiUpdatePeopleRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersonApi
     */
    public updatePeople(requestParameters: PersonApiUpdatePeopleRequest, options?: AxiosRequestConfig) {
        return PersonApiFp(this.configuration).updatePeople(requestParameters.peopleUpdateDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {PersonApiUpdatePersonRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersonApi
     */
    public updatePerson(requestParameters: PersonApiUpdatePersonRequest, options?: AxiosRequestConfig) {
        return PersonApiFp(this.configuration).updatePerson(requestParameters.id, requestParameters.personUpdateDto, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * SearchApi - axios parameter creator
 * @export
 */
export const SearchApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExploreData: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/search/explore`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookie required

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {string} [q]
         * @param {string} [query]
         * @param {boolean} [clip]
         * @param {'IMAGE' | 'VIDEO' | 'AUDIO' | 'OTHER'} [type]
         * @param {boolean} [recent]
         * @param {boolean} [motion]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search: async (q?: string, query?: string, clip?: boolean, type?: 'IMAGE' | 'VIDEO' | 'AUDIO' | 'OTHER', recent?: boolean, motion?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/search`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookie required

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            if (clip !== undefined) {
                localVarQueryParameter['clip'] = clip;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (recent !== undefined) {
                localVarQueryParameter['recent'] = recent;
            }

            if (motion !== undefined) {
                localVarQueryParameter['motion'] = motion;
            }


            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {string} name
         * @param {boolean} [withHidden]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchPerson: async (name: string, withHidden?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            assertParamExists('searchPerson', 'name', name)
            const localVarPath = `/search/person`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookie required

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (withHidden !== undefined) {
                localVarQueryParameter['withHidden'] = withHidden;
            }


            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SearchApi - functional programming interface
 * @export
 */
export const SearchApiFp = function (configuration?: Configuration) {
    const localVarAxiosParamCreator = SearchApiAxiosParamCreator(configuration)
    return {
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getExploreData(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<SearchExploreResponseDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getExploreData(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {string} [q]
         * @param {string} [query]
         * @param {boolean} [clip]
         * @param {'IMAGE' | 'VIDEO' | 'AUDIO' | 'OTHER'} [type]
         * @param {boolean} [recent]
         * @param {boolean} [motion]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async search(q?: string, query?: string, clip?: boolean, type?: 'IMAGE' | 'VIDEO' | 'AUDIO' | 'OTHER', recent?: boolean, motion?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SearchResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.search(q, query, clip, type, recent, motion, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {string} name
         * @param {boolean} [withHidden]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchPerson(name: string, withHidden?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PersonResponseDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchPerson(name, withHidden, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * SearchApi - factory interface
 * @export
 */
export const SearchApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SearchApiFp(configuration)
    return {
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExploreData(options?: AxiosRequestConfig): AxiosPromise<Array<SearchExploreResponseDto>> {
            return localVarFp.getExploreData(options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {SearchApiSearchRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search(requestParameters: SearchApiSearchRequest = {}, options?: AxiosRequestConfig): AxiosPromise<SearchResponseDto> {
            return localVarFp.search(requestParameters.q, requestParameters.query, requestParameters.clip, requestParameters.type, requestParameters.recent, requestParameters.motion, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {SearchApiSearchPersonRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchPerson(requestParameters: SearchApiSearchPersonRequest, options?: AxiosRequestConfig): AxiosPromise<Array<PersonResponseDto>> {
            return localVarFp.searchPerson(requestParameters.name, requestParameters.withHidden, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for search operation in SearchApi.
 * @export
 * @interface SearchApiSearchRequest
 */
export interface SearchApiSearchRequest {
    /**
     *
     * @type {string}
     * @memberof SearchApiSearch
     */
    readonly q?: string

    /**
     *
     * @type {string}
     * @memberof SearchApiSearch
     */
    readonly query?: string

    /**
     *
     * @type {boolean}
     * @memberof SearchApiSearch
     */
    readonly clip?: boolean

    /**
     *
     * @type {'IMAGE' | 'VIDEO' | 'AUDIO' | 'OTHER'}
     * @memberof SearchApiSearch
     */
    readonly type?: 'IMAGE' | 'VIDEO' | 'AUDIO' | 'OTHER'

    /**
     *
     * @type {boolean}
     * @memberof SearchApiSearch
     */
    readonly recent?: boolean

    /**
     *
     * @type {boolean}
     * @memberof SearchApiSearch
     */
    readonly motion?: boolean
}

/**
 * Request parameters for searchPerson operation in SearchApi.
 * @export
 * @interface SearchApiSearchPersonRequest
 */
export interface SearchApiSearchPersonRequest {
    /**
     *
     * @type {string}
     * @memberof SearchApiSearchPerson
     */
    readonly name: string

    /**
     *
     * @type {boolean}
     * @memberof SearchApiSearchPerson
     */
    readonly withHidden?: boolean
}

/**
 * SearchApi - object-oriented interface
 * @export
 * @class SearchApi
 * @extends {BaseAPI}
 */
export class SearchApi extends BaseAPI {
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SearchApi
     */
    public getExploreData(options?: AxiosRequestConfig) {
        return SearchApiFp(this.configuration).getExploreData(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {SearchApiSearchRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SearchApi
     */
    public search(requestParameters: SearchApiSearchRequest = {}, options?: AxiosRequestConfig) {
        return SearchApiFp(this.configuration).search(requestParameters.q, requestParameters.query, requestParameters.clip, requestParameters.type, requestParameters.recent, requestParameters.motion, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {SearchApiSearchPersonRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SearchApi
     */
    public searchPerson(requestParameters: SearchApiSearchPersonRequest, options?: AxiosRequestConfig) {
        return SearchApiFp(this.configuration).searchPerson(requestParameters.name, requestParameters.withHidden, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ServerInfoApi - axios parameter creator
 * @export
 */
export const ServerInfoApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getServerConfig: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/server-info/config`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getServerFeatures: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/server-info/features`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getServerInfo: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/server-info`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookie required

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getServerStatistics: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/server-info/statistics`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookie required

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getServerVersion: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/server-info/version`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSupportedMediaTypes: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/server-info/media-types`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTheme: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/server-info/theme`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pingServer: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/server-info/ping`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ServerInfoApi - functional programming interface
 * @export
 */
export const ServerInfoApiFp = function (configuration?: Configuration) {
    const localVarAxiosParamCreator = ServerInfoApiAxiosParamCreator(configuration)
    return {
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getServerConfig(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ServerConfigDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getServerConfig(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getServerFeatures(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ServerFeaturesDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getServerFeatures(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getServerInfo(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ServerInfoResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getServerInfo(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getServerStatistics(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ServerStatsResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getServerStatistics(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getServerVersion(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ServerVersionResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getServerVersion(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSupportedMediaTypes(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ServerMediaTypesResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSupportedMediaTypes(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTheme(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ServerThemeDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTheme(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pingServer(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ServerPingResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pingServer(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ServerInfoApi - factory interface
 * @export
 */
export const ServerInfoApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ServerInfoApiFp(configuration)
    return {
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getServerConfig(options?: AxiosRequestConfig): AxiosPromise<ServerConfigDto> {
            return localVarFp.getServerConfig(options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getServerFeatures(options?: AxiosRequestConfig): AxiosPromise<ServerFeaturesDto> {
            return localVarFp.getServerFeatures(options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getServerInfo(options?: AxiosRequestConfig): AxiosPromise<ServerInfoResponseDto> {
            return localVarFp.getServerInfo(options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getServerStatistics(options?: AxiosRequestConfig): AxiosPromise<ServerStatsResponseDto> {
            return localVarFp.getServerStatistics(options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getServerVersion(options?: AxiosRequestConfig): AxiosPromise<ServerVersionResponseDto> {
            return localVarFp.getServerVersion(options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSupportedMediaTypes(options?: AxiosRequestConfig): AxiosPromise<ServerMediaTypesResponseDto> {
            return localVarFp.getSupportedMediaTypes(options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTheme(options?: AxiosRequestConfig): AxiosPromise<ServerThemeDto> {
            return localVarFp.getTheme(options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pingServer(options?: AxiosRequestConfig): AxiosPromise<ServerPingResponse> {
            return localVarFp.pingServer(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ServerInfoApi - object-oriented interface
 * @export
 * @class ServerInfoApi
 * @extends {BaseAPI}
 */
export class ServerInfoApi extends BaseAPI {
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServerInfoApi
     */
    public getServerConfig(options?: AxiosRequestConfig) {
        return ServerInfoApiFp(this.configuration).getServerConfig(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServerInfoApi
     */
    public getServerFeatures(options?: AxiosRequestConfig) {
        return ServerInfoApiFp(this.configuration).getServerFeatures(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServerInfoApi
     */
    public getServerInfo(options?: AxiosRequestConfig) {
        return ServerInfoApiFp(this.configuration).getServerInfo(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServerInfoApi
     */
    public getServerStatistics(options?: AxiosRequestConfig) {
        return ServerInfoApiFp(this.configuration).getServerStatistics(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServerInfoApi
     */
    public getServerVersion(options?: AxiosRequestConfig) {
        return ServerInfoApiFp(this.configuration).getServerVersion(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServerInfoApi
     */
    public getSupportedMediaTypes(options?: AxiosRequestConfig) {
        return ServerInfoApiFp(this.configuration).getSupportedMediaTypes(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServerInfoApi
     */
    public getTheme(options?: AxiosRequestConfig) {
        return ServerInfoApiFp(this.configuration).getTheme(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServerInfoApi
     */
    public pingServer(options?: AxiosRequestConfig) {
        return ServerInfoApiFp(this.configuration).pingServer(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * SharedLinkApi - axios parameter creator
 * @export
 */
export const SharedLinkApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *
         * @param {string} id
         * @param {AssetIdsDto} assetIdsDto
         * @param {string} [key]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addSharedLinkAssets: async (id: string, assetIdsDto: AssetIdsDto, key?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('addSharedLinkAssets', 'id', id)
            // verify required parameter 'assetIdsDto' is not null or undefined
            assertParamExists('addSharedLinkAssets', 'assetIdsDto', assetIdsDto)
            const localVarPath = `/shared-link/{id}/assets`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookie required

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (key !== undefined) {
                localVarQueryParameter['key'] = key;
            }


            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(assetIdsDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {SharedLinkCreateDto} sharedLinkCreateDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSharedLink: async (sharedLinkCreateDto: SharedLinkCreateDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sharedLinkCreateDto' is not null or undefined
            assertParamExists('createSharedLink', 'sharedLinkCreateDto', sharedLinkCreateDto)
            const localVarPath = `/shared-link`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookie required

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(sharedLinkCreateDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllSharedLinks: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/shared-link`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookie required

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {string} [password]
         * @param {string} [token]
         * @param {string} [key]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMySharedLink: async (password?: string, token?: string, key?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/shared-link/me`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookie required

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (password !== undefined) {
                localVarQueryParameter['password'] = password;
            }

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }

            if (key !== undefined) {
                localVarQueryParameter['key'] = key;
            }


            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSharedLinkById: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getSharedLinkById', 'id', id)
            const localVarPath = `/shared-link/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookie required

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeSharedLink: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('removeSharedLink', 'id', id)
            const localVarPath = `/shared-link/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookie required

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {string} id
         * @param {AssetIdsDto} assetIdsDto
         * @param {string} [key]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeSharedLinkAssets: async (id: string, assetIdsDto: AssetIdsDto, key?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('removeSharedLinkAssets', 'id', id)
            // verify required parameter 'assetIdsDto' is not null or undefined
            assertParamExists('removeSharedLinkAssets', 'assetIdsDto', assetIdsDto)
            const localVarPath = `/shared-link/{id}/assets`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookie required

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (key !== undefined) {
                localVarQueryParameter['key'] = key;
            }


            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(assetIdsDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {string} id
         * @param {SharedLinkEditDto} sharedLinkEditDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSharedLink: async (id: string, sharedLinkEditDto: SharedLinkEditDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateSharedLink', 'id', id)
            // verify required parameter 'sharedLinkEditDto' is not null or undefined
            assertParamExists('updateSharedLink', 'sharedLinkEditDto', sharedLinkEditDto)
            const localVarPath = `/shared-link/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookie required

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(sharedLinkEditDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SharedLinkApi - functional programming interface
 * @export
 */
export const SharedLinkApiFp = function (configuration?: Configuration) {
    const localVarAxiosParamCreator = SharedLinkApiAxiosParamCreator(configuration)
    return {
        /**
         *
         * @param {string} id
         * @param {AssetIdsDto} assetIdsDto
         * @param {string} [key]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addSharedLinkAssets(id: string, assetIdsDto: AssetIdsDto, key?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AssetIdsResponseDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addSharedLinkAssets(id, assetIdsDto, key, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {SharedLinkCreateDto} sharedLinkCreateDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createSharedLink(sharedLinkCreateDto: SharedLinkCreateDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SharedLinkResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createSharedLink(sharedLinkCreateDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllSharedLinks(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<SharedLinkResponseDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllSharedLinks(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {string} [password]
         * @param {string} [token]
         * @param {string} [key]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMySharedLink(password?: string, token?: string, key?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SharedLinkResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMySharedLink(password, token, key, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSharedLinkById(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SharedLinkResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSharedLinkById(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async removeSharedLink(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.removeSharedLink(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {string} id
         * @param {AssetIdsDto} assetIdsDto
         * @param {string} [key]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async removeSharedLinkAssets(id: string, assetIdsDto: AssetIdsDto, key?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AssetIdsResponseDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.removeSharedLinkAssets(id, assetIdsDto, key, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {string} id
         * @param {SharedLinkEditDto} sharedLinkEditDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateSharedLink(id: string, sharedLinkEditDto: SharedLinkEditDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SharedLinkResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateSharedLink(id, sharedLinkEditDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * SharedLinkApi - factory interface
 * @export
 */
export const SharedLinkApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SharedLinkApiFp(configuration)
    return {
        /**
         *
         * @param {SharedLinkApiAddSharedLinkAssetsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addSharedLinkAssets(requestParameters: SharedLinkApiAddSharedLinkAssetsRequest, options?: AxiosRequestConfig): AxiosPromise<Array<AssetIdsResponseDto>> {
            return localVarFp.addSharedLinkAssets(requestParameters.id, requestParameters.assetIdsDto, requestParameters.key, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {SharedLinkApiCreateSharedLinkRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSharedLink(requestParameters: SharedLinkApiCreateSharedLinkRequest, options?: AxiosRequestConfig): AxiosPromise<SharedLinkResponseDto> {
            return localVarFp.createSharedLink(requestParameters.sharedLinkCreateDto, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllSharedLinks(options?: AxiosRequestConfig): AxiosPromise<Array<SharedLinkResponseDto>> {
            return localVarFp.getAllSharedLinks(options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {SharedLinkApiGetMySharedLinkRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMySharedLink(requestParameters: SharedLinkApiGetMySharedLinkRequest = {}, options?: AxiosRequestConfig): AxiosPromise<SharedLinkResponseDto> {
            return localVarFp.getMySharedLink(requestParameters.password, requestParameters.token, requestParameters.key, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {SharedLinkApiGetSharedLinkByIdRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSharedLinkById(requestParameters: SharedLinkApiGetSharedLinkByIdRequest, options?: AxiosRequestConfig): AxiosPromise<SharedLinkResponseDto> {
            return localVarFp.getSharedLinkById(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {SharedLinkApiRemoveSharedLinkRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeSharedLink(requestParameters: SharedLinkApiRemoveSharedLinkRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.removeSharedLink(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {SharedLinkApiRemoveSharedLinkAssetsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeSharedLinkAssets(requestParameters: SharedLinkApiRemoveSharedLinkAssetsRequest, options?: AxiosRequestConfig): AxiosPromise<Array<AssetIdsResponseDto>> {
            return localVarFp.removeSharedLinkAssets(requestParameters.id, requestParameters.assetIdsDto, requestParameters.key, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {SharedLinkApiUpdateSharedLinkRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSharedLink(requestParameters: SharedLinkApiUpdateSharedLinkRequest, options?: AxiosRequestConfig): AxiosPromise<SharedLinkResponseDto> {
            return localVarFp.updateSharedLink(requestParameters.id, requestParameters.sharedLinkEditDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for addSharedLinkAssets operation in SharedLinkApi.
 * @export
 * @interface SharedLinkApiAddSharedLinkAssetsRequest
 */
export interface SharedLinkApiAddSharedLinkAssetsRequest {
    /**
     *
     * @type {string}
     * @memberof SharedLinkApiAddSharedLinkAssets
     */
    readonly id: string

    /**
     *
     * @type {AssetIdsDto}
     * @memberof SharedLinkApiAddSharedLinkAssets
     */
    readonly assetIdsDto: AssetIdsDto

    /**
     *
     * @type {string}
     * @memberof SharedLinkApiAddSharedLinkAssets
     */
    readonly key?: string
}

/**
 * Request parameters for createSharedLink operation in SharedLinkApi.
 * @export
 * @interface SharedLinkApiCreateSharedLinkRequest
 */
export interface SharedLinkApiCreateSharedLinkRequest {
    /**
     *
     * @type {SharedLinkCreateDto}
     * @memberof SharedLinkApiCreateSharedLink
     */
    readonly sharedLinkCreateDto: SharedLinkCreateDto
}

/**
 * Request parameters for getMySharedLink operation in SharedLinkApi.
 * @export
 * @interface SharedLinkApiGetMySharedLinkRequest
 */
export interface SharedLinkApiGetMySharedLinkRequest {
    /**
     *
     * @type {string}
     * @memberof SharedLinkApiGetMySharedLink
     */
    readonly password?: string

    /**
     *
     * @type {string}
     * @memberof SharedLinkApiGetMySharedLink
     */
    readonly token?: string

    /**
     *
     * @type {string}
     * @memberof SharedLinkApiGetMySharedLink
     */
    readonly key?: string
}

/**
 * Request parameters for getSharedLinkById operation in SharedLinkApi.
 * @export
 * @interface SharedLinkApiGetSharedLinkByIdRequest
 */
export interface SharedLinkApiGetSharedLinkByIdRequest {
    /**
     *
     * @type {string}
     * @memberof SharedLinkApiGetSharedLinkById
     */
    readonly id: string
}

/**
 * Request parameters for removeSharedLink operation in SharedLinkApi.
 * @export
 * @interface SharedLinkApiRemoveSharedLinkRequest
 */
export interface SharedLinkApiRemoveSharedLinkRequest {
    /**
     *
     * @type {string}
     * @memberof SharedLinkApiRemoveSharedLink
     */
    readonly id: string
}

/**
 * Request parameters for removeSharedLinkAssets operation in SharedLinkApi.
 * @export
 * @interface SharedLinkApiRemoveSharedLinkAssetsRequest
 */
export interface SharedLinkApiRemoveSharedLinkAssetsRequest {
    /**
     *
     * @type {string}
     * @memberof SharedLinkApiRemoveSharedLinkAssets
     */
    readonly id: string

    /**
     *
     * @type {AssetIdsDto}
     * @memberof SharedLinkApiRemoveSharedLinkAssets
     */
    readonly assetIdsDto: AssetIdsDto

    /**
     *
     * @type {string}
     * @memberof SharedLinkApiRemoveSharedLinkAssets
     */
    readonly key?: string
}

/**
 * Request parameters for updateSharedLink operation in SharedLinkApi.
 * @export
 * @interface SharedLinkApiUpdateSharedLinkRequest
 */
export interface SharedLinkApiUpdateSharedLinkRequest {
    /**
     *
     * @type {string}
     * @memberof SharedLinkApiUpdateSharedLink
     */
    readonly id: string

    /**
     *
     * @type {SharedLinkEditDto}
     * @memberof SharedLinkApiUpdateSharedLink
     */
    readonly sharedLinkEditDto: SharedLinkEditDto
}

/**
 * SharedLinkApi - object-oriented interface
 * @export
 * @class SharedLinkApi
 * @extends {BaseAPI}
 */
export class SharedLinkApi extends BaseAPI {
    /**
     *
     * @param {SharedLinkApiAddSharedLinkAssetsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SharedLinkApi
     */
    public addSharedLinkAssets(requestParameters: SharedLinkApiAddSharedLinkAssetsRequest, options?: AxiosRequestConfig) {
        return SharedLinkApiFp(this.configuration).addSharedLinkAssets(requestParameters.id, requestParameters.assetIdsDto, requestParameters.key, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {SharedLinkApiCreateSharedLinkRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SharedLinkApi
     */
    public createSharedLink(requestParameters: SharedLinkApiCreateSharedLinkRequest, options?: AxiosRequestConfig) {
        return SharedLinkApiFp(this.configuration).createSharedLink(requestParameters.sharedLinkCreateDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SharedLinkApi
     */
    public getAllSharedLinks(options?: AxiosRequestConfig) {
        return SharedLinkApiFp(this.configuration).getAllSharedLinks(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {SharedLinkApiGetMySharedLinkRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SharedLinkApi
     */
    public getMySharedLink(requestParameters: SharedLinkApiGetMySharedLinkRequest = {}, options?: AxiosRequestConfig) {
        return SharedLinkApiFp(this.configuration).getMySharedLink(requestParameters.password, requestParameters.token, requestParameters.key, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {SharedLinkApiGetSharedLinkByIdRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SharedLinkApi
     */
    public getSharedLinkById(requestParameters: SharedLinkApiGetSharedLinkByIdRequest, options?: AxiosRequestConfig) {
        return SharedLinkApiFp(this.configuration).getSharedLinkById(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {SharedLinkApiRemoveSharedLinkRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SharedLinkApi
     */
    public removeSharedLink(requestParameters: SharedLinkApiRemoveSharedLinkRequest, options?: AxiosRequestConfig) {
        return SharedLinkApiFp(this.configuration).removeSharedLink(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {SharedLinkApiRemoveSharedLinkAssetsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SharedLinkApi
     */
    public removeSharedLinkAssets(requestParameters: SharedLinkApiRemoveSharedLinkAssetsRequest, options?: AxiosRequestConfig) {
        return SharedLinkApiFp(this.configuration).removeSharedLinkAssets(requestParameters.id, requestParameters.assetIdsDto, requestParameters.key, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {SharedLinkApiUpdateSharedLinkRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SharedLinkApi
     */
    public updateSharedLink(requestParameters: SharedLinkApiUpdateSharedLinkRequest, options?: AxiosRequestConfig) {
        return SharedLinkApiFp(this.configuration).updateSharedLink(requestParameters.id, requestParameters.sharedLinkEditDto, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * SystemConfigApi - axios parameter creator
 * @export
 */
export const SystemConfigApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConfig: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/system-config`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookie required

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConfigDefaults: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/system-config/defaults`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookie required

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {MapTheme} theme
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMapStyle: async (theme: MapTheme, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'theme' is not null or undefined
            assertParamExists('getMapStyle', 'theme', theme)
            const localVarPath = `/system-config/map/style.json`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookie required

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (theme !== undefined) {
                localVarQueryParameter['theme'] = theme;
            }


            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStorageTemplateOptions: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/system-config/storage-template-options`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookie required

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {SystemConfigDto} systemConfigDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateConfig: async (systemConfigDto: SystemConfigDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'systemConfigDto' is not null or undefined
            assertParamExists('updateConfig', 'systemConfigDto', systemConfigDto)
            const localVarPath = `/system-config`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookie required

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(systemConfigDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SystemConfigApi - functional programming interface
 * @export
 */
export const SystemConfigApiFp = function (configuration?: Configuration) {
    const localVarAxiosParamCreator = SystemConfigApiAxiosParamCreator(configuration)
    return {
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getConfig(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SystemConfigDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getConfig(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getConfigDefaults(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SystemConfigDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getConfigDefaults(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {MapTheme} theme
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMapStyle(theme: MapTheme, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMapStyle(theme, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStorageTemplateOptions(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SystemConfigTemplateStorageOptionDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getStorageTemplateOptions(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {SystemConfigDto} systemConfigDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateConfig(systemConfigDto: SystemConfigDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SystemConfigDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateConfig(systemConfigDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * SystemConfigApi - factory interface
 * @export
 */
export const SystemConfigApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SystemConfigApiFp(configuration)
    return {
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConfig(options?: AxiosRequestConfig): AxiosPromise<SystemConfigDto> {
            return localVarFp.getConfig(options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConfigDefaults(options?: AxiosRequestConfig): AxiosPromise<SystemConfigDto> {
            return localVarFp.getConfigDefaults(options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {SystemConfigApiGetMapStyleRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMapStyle(requestParameters: SystemConfigApiGetMapStyleRequest, options?: AxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.getMapStyle(requestParameters.theme, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStorageTemplateOptions(options?: AxiosRequestConfig): AxiosPromise<SystemConfigTemplateStorageOptionDto> {
            return localVarFp.getStorageTemplateOptions(options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {SystemConfigApiUpdateConfigRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateConfig(requestParameters: SystemConfigApiUpdateConfigRequest, options?: AxiosRequestConfig): AxiosPromise<SystemConfigDto> {
            return localVarFp.updateConfig(requestParameters.systemConfigDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for getMapStyle operation in SystemConfigApi.
 * @export
 * @interface SystemConfigApiGetMapStyleRequest
 */
export interface SystemConfigApiGetMapStyleRequest {
    /**
     *
     * @type {MapTheme}
     * @memberof SystemConfigApiGetMapStyle
     */
    readonly theme: MapTheme
}

/**
 * Request parameters for updateConfig operation in SystemConfigApi.
 * @export
 * @interface SystemConfigApiUpdateConfigRequest
 */
export interface SystemConfigApiUpdateConfigRequest {
    /**
     *
     * @type {SystemConfigDto}
     * @memberof SystemConfigApiUpdateConfig
     */
    readonly systemConfigDto: SystemConfigDto
}

/**
 * SystemConfigApi - object-oriented interface
 * @export
 * @class SystemConfigApi
 * @extends {BaseAPI}
 */
export class SystemConfigApi extends BaseAPI {
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SystemConfigApi
     */
    public getConfig(options?: AxiosRequestConfig) {
        return SystemConfigApiFp(this.configuration).getConfig(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SystemConfigApi
     */
    public getConfigDefaults(options?: AxiosRequestConfig) {
        return SystemConfigApiFp(this.configuration).getConfigDefaults(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {SystemConfigApiGetMapStyleRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SystemConfigApi
     */
    public getMapStyle(requestParameters: SystemConfigApiGetMapStyleRequest, options?: AxiosRequestConfig) {
        return SystemConfigApiFp(this.configuration).getMapStyle(requestParameters.theme, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SystemConfigApi
     */
    public getStorageTemplateOptions(options?: AxiosRequestConfig) {
        return SystemConfigApiFp(this.configuration).getStorageTemplateOptions(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {SystemConfigApiUpdateConfigRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SystemConfigApi
     */
    public updateConfig(requestParameters: SystemConfigApiUpdateConfigRequest, options?: AxiosRequestConfig) {
        return SystemConfigApiFp(this.configuration).updateConfig(requestParameters.systemConfigDto, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * TagApi - axios parameter creator
 * @export
 */
export const TagApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *
         * @param {CreateTagDto} createTagDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTag: async (createTagDto: CreateTagDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createTagDto' is not null or undefined
            assertParamExists('createTag', 'createTagDto', createTagDto)
            const localVarPath = `/tag`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookie required

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createTagDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTag: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteTag', 'id', id)
            const localVarPath = `/tag/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookie required

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllTags: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/tag`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookie required

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTagAssets: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getTagAssets', 'id', id)
            const localVarPath = `/tag/{id}/assets`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookie required

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTagById: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getTagById', 'id', id)
            const localVarPath = `/tag/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookie required

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {string} id
         * @param {AssetIdsDto} assetIdsDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagAssets: async (id: string, assetIdsDto: AssetIdsDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('tagAssets', 'id', id)
            // verify required parameter 'assetIdsDto' is not null or undefined
            assertParamExists('tagAssets', 'assetIdsDto', assetIdsDto)
            const localVarPath = `/tag/{id}/assets`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookie required

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(assetIdsDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {string} id
         * @param {AssetIdsDto} assetIdsDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        untagAssets: async (id: string, assetIdsDto: AssetIdsDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('untagAssets', 'id', id)
            // verify required parameter 'assetIdsDto' is not null or undefined
            assertParamExists('untagAssets', 'assetIdsDto', assetIdsDto)
            const localVarPath = `/tag/{id}/assets`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookie required

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(assetIdsDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {string} id
         * @param {UpdateTagDto} updateTagDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTag: async (id: string, updateTagDto: UpdateTagDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateTag', 'id', id)
            // verify required parameter 'updateTagDto' is not null or undefined
            assertParamExists('updateTag', 'updateTagDto', updateTagDto)
            const localVarPath = `/tag/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookie required

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateTagDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TagApi - functional programming interface
 * @export
 */
export const TagApiFp = function (configuration?: Configuration) {
    const localVarAxiosParamCreator = TagApiAxiosParamCreator(configuration)
    return {
        /**
         *
         * @param {CreateTagDto} createTagDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createTag(createTagDto: CreateTagDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TagResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createTag(createTagDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteTag(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteTag(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllTags(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TagResponseDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllTags(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTagAssets(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AssetResponseDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTagAssets(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTagById(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TagResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTagById(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {string} id
         * @param {AssetIdsDto} assetIdsDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tagAssets(id: string, assetIdsDto: AssetIdsDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AssetIdsResponseDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tagAssets(id, assetIdsDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {string} id
         * @param {AssetIdsDto} assetIdsDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async untagAssets(id: string, assetIdsDto: AssetIdsDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AssetIdsResponseDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.untagAssets(id, assetIdsDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {string} id
         * @param {UpdateTagDto} updateTagDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateTag(id: string, updateTagDto: UpdateTagDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TagResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateTag(id, updateTagDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * TagApi - factory interface
 * @export
 */
export const TagApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TagApiFp(configuration)
    return {
        /**
         *
         * @param {TagApiCreateTagRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTag(requestParameters: TagApiCreateTagRequest, options?: AxiosRequestConfig): AxiosPromise<TagResponseDto> {
            return localVarFp.createTag(requestParameters.createTagDto, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {TagApiDeleteTagRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTag(requestParameters: TagApiDeleteTagRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteTag(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllTags(options?: AxiosRequestConfig): AxiosPromise<Array<TagResponseDto>> {
            return localVarFp.getAllTags(options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {TagApiGetTagAssetsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTagAssets(requestParameters: TagApiGetTagAssetsRequest, options?: AxiosRequestConfig): AxiosPromise<Array<AssetResponseDto>> {
            return localVarFp.getTagAssets(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {TagApiGetTagByIdRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTagById(requestParameters: TagApiGetTagByIdRequest, options?: AxiosRequestConfig): AxiosPromise<TagResponseDto> {
            return localVarFp.getTagById(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {TagApiTagAssetsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagAssets(requestParameters: TagApiTagAssetsRequest, options?: AxiosRequestConfig): AxiosPromise<Array<AssetIdsResponseDto>> {
            return localVarFp.tagAssets(requestParameters.id, requestParameters.assetIdsDto, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {TagApiUntagAssetsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        untagAssets(requestParameters: TagApiUntagAssetsRequest, options?: AxiosRequestConfig): AxiosPromise<Array<AssetIdsResponseDto>> {
            return localVarFp.untagAssets(requestParameters.id, requestParameters.assetIdsDto, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {TagApiUpdateTagRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTag(requestParameters: TagApiUpdateTagRequest, options?: AxiosRequestConfig): AxiosPromise<TagResponseDto> {
            return localVarFp.updateTag(requestParameters.id, requestParameters.updateTagDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createTag operation in TagApi.
 * @export
 * @interface TagApiCreateTagRequest
 */
export interface TagApiCreateTagRequest {
    /**
     *
     * @type {CreateTagDto}
     * @memberof TagApiCreateTag
     */
    readonly createTagDto: CreateTagDto
}

/**
 * Request parameters for deleteTag operation in TagApi.
 * @export
 * @interface TagApiDeleteTagRequest
 */
export interface TagApiDeleteTagRequest {
    /**
     *
     * @type {string}
     * @memberof TagApiDeleteTag
     */
    readonly id: string
}

/**
 * Request parameters for getTagAssets operation in TagApi.
 * @export
 * @interface TagApiGetTagAssetsRequest
 */
export interface TagApiGetTagAssetsRequest {
    /**
     *
     * @type {string}
     * @memberof TagApiGetTagAssets
     */
    readonly id: string
}

/**
 * Request parameters for getTagById operation in TagApi.
 * @export
 * @interface TagApiGetTagByIdRequest
 */
export interface TagApiGetTagByIdRequest {
    /**
     *
     * @type {string}
     * @memberof TagApiGetTagById
     */
    readonly id: string
}

/**
 * Request parameters for tagAssets operation in TagApi.
 * @export
 * @interface TagApiTagAssetsRequest
 */
export interface TagApiTagAssetsRequest {
    /**
     *
     * @type {string}
     * @memberof TagApiTagAssets
     */
    readonly id: string

    /**
     *
     * @type {AssetIdsDto}
     * @memberof TagApiTagAssets
     */
    readonly assetIdsDto: AssetIdsDto
}

/**
 * Request parameters for untagAssets operation in TagApi.
 * @export
 * @interface TagApiUntagAssetsRequest
 */
export interface TagApiUntagAssetsRequest {
    /**
     *
     * @type {string}
     * @memberof TagApiUntagAssets
     */
    readonly id: string

    /**
     *
     * @type {AssetIdsDto}
     * @memberof TagApiUntagAssets
     */
    readonly assetIdsDto: AssetIdsDto
}

/**
 * Request parameters for updateTag operation in TagApi.
 * @export
 * @interface TagApiUpdateTagRequest
 */
export interface TagApiUpdateTagRequest {
    /**
     *
     * @type {string}
     * @memberof TagApiUpdateTag
     */
    readonly id: string

    /**
     *
     * @type {UpdateTagDto}
     * @memberof TagApiUpdateTag
     */
    readonly updateTagDto: UpdateTagDto
}

/**
 * TagApi - object-oriented interface
 * @export
 * @class TagApi
 * @extends {BaseAPI}
 */
export class TagApi extends BaseAPI {
    /**
     *
     * @param {TagApiCreateTagRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagApi
     */
    public createTag(requestParameters: TagApiCreateTagRequest, options?: AxiosRequestConfig) {
        return TagApiFp(this.configuration).createTag(requestParameters.createTagDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {TagApiDeleteTagRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagApi
     */
    public deleteTag(requestParameters: TagApiDeleteTagRequest, options?: AxiosRequestConfig) {
        return TagApiFp(this.configuration).deleteTag(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagApi
     */
    public getAllTags(options?: AxiosRequestConfig) {
        return TagApiFp(this.configuration).getAllTags(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {TagApiGetTagAssetsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagApi
     */
    public getTagAssets(requestParameters: TagApiGetTagAssetsRequest, options?: AxiosRequestConfig) {
        return TagApiFp(this.configuration).getTagAssets(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {TagApiGetTagByIdRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagApi
     */
    public getTagById(requestParameters: TagApiGetTagByIdRequest, options?: AxiosRequestConfig) {
        return TagApiFp(this.configuration).getTagById(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {TagApiTagAssetsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagApi
     */
    public tagAssets(requestParameters: TagApiTagAssetsRequest, options?: AxiosRequestConfig) {
        return TagApiFp(this.configuration).tagAssets(requestParameters.id, requestParameters.assetIdsDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {TagApiUntagAssetsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagApi
     */
    public untagAssets(requestParameters: TagApiUntagAssetsRequest, options?: AxiosRequestConfig) {
        return TagApiFp(this.configuration).untagAssets(requestParameters.id, requestParameters.assetIdsDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {TagApiUpdateTagRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagApi
     */
    public updateTag(requestParameters: TagApiUpdateTagRequest, options?: AxiosRequestConfig) {
        return TagApiFp(this.configuration).updateTag(requestParameters.id, requestParameters.updateTagDto, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * UserApi - axios parameter creator
 * @export
 */
export const UserApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *
         * @param {File} file
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProfileImage: async (file: File, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'file' is not null or undefined
            assertParamExists('createProfileImage', 'file', file)
            const localVarPath = `/user/profile-image`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication cookie required

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


            if (file !== undefined) {
                localVarFormParams.append('file', file as any);
            }


            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {CreateUserDto} createUserDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUser: async (createUserDto: CreateUserDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createUserDto' is not null or undefined
            assertParamExists('createUser', 'createUserDto', createUserDto)
            const localVarPath = `/user`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookie required

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createUserDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProfileImage: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/user/profile-image`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookie required

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUser: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteUser', 'id', id)
            const localVarPath = `/user/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookie required

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {boolean} isAll
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllUsers: async (isAll: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'isAll' is not null or undefined
            assertParamExists('getAllUsers', 'isAll', isAll)
            const localVarPath = `/user`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookie required

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (isAll !== undefined) {
                localVarQueryParameter['isAll'] = isAll;
            }


            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMyUserInfo: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/user/me`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookie required

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProfileImage: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getProfileImage', 'id', id)
            const localVarPath = `/user/profile-image/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookie required

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserById: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getUserById', 'id', id)
            const localVarPath = `/user/info/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookie required

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        restoreUser: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('restoreUser', 'id', id)
            const localVarPath = `/user/{id}/restore`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookie required

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {UpdateUserDto} updateUserDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUser: async (updateUserDto: UpdateUserDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'updateUserDto' is not null or undefined
            assertParamExists('updateUser', 'updateUserDto', updateUserDto)
            const localVarPath = `/user`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookie required

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateUserDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UserApi - functional programming interface
 * @export
 */
export const UserApiFp = function (configuration?: Configuration) {
    const localVarAxiosParamCreator = UserApiAxiosParamCreator(configuration)
    return {
        /**
         *
         * @param {File} file
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createProfileImage(file: File, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateProfileImageResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createProfileImage(file, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {CreateUserDto} createUserDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createUser(createUserDto: CreateUserDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createUser(createUserDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteProfileImage(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteProfileImage(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteUser(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteUser(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {boolean} isAll
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllUsers(isAll: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UserResponseDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllUsers(isAll, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMyUserInfo(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMyUserInfo(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProfileImage(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<File>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getProfileImage(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserById(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserById(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async restoreUser(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.restoreUser(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {UpdateUserDto} updateUserDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateUser(updateUserDto: UpdateUserDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateUser(updateUserDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * UserApi - factory interface
 * @export
 */
export const UserApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UserApiFp(configuration)
    return {
        /**
         *
         * @param {UserApiCreateProfileImageRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProfileImage(requestParameters: UserApiCreateProfileImageRequest, options?: AxiosRequestConfig): AxiosPromise<CreateProfileImageResponseDto> {
            return localVarFp.createProfileImage(requestParameters.file, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {UserApiCreateUserRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUser(requestParameters: UserApiCreateUserRequest, options?: AxiosRequestConfig): AxiosPromise<UserResponseDto> {
            return localVarFp.createUser(requestParameters.createUserDto, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProfileImage(options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteProfileImage(options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {UserApiDeleteUserRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUser(requestParameters: UserApiDeleteUserRequest, options?: AxiosRequestConfig): AxiosPromise<UserResponseDto> {
            return localVarFp.deleteUser(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {UserApiGetAllUsersRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllUsers(requestParameters: UserApiGetAllUsersRequest, options?: AxiosRequestConfig): AxiosPromise<Array<UserResponseDto>> {
            return localVarFp.getAllUsers(requestParameters.isAll, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMyUserInfo(options?: AxiosRequestConfig): AxiosPromise<UserResponseDto> {
            return localVarFp.getMyUserInfo(options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {UserApiGetProfileImageRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProfileImage(requestParameters: UserApiGetProfileImageRequest, options?: AxiosRequestConfig): AxiosPromise<File> {
            return localVarFp.getProfileImage(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {UserApiGetUserByIdRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserById(requestParameters: UserApiGetUserByIdRequest, options?: AxiosRequestConfig): AxiosPromise<UserResponseDto> {
            return localVarFp.getUserById(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {UserApiRestoreUserRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        restoreUser(requestParameters: UserApiRestoreUserRequest, options?: AxiosRequestConfig): AxiosPromise<UserResponseDto> {
            return localVarFp.restoreUser(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {UserApiUpdateUserRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUser(requestParameters: UserApiUpdateUserRequest, options?: AxiosRequestConfig): AxiosPromise<UserResponseDto> {
            return localVarFp.updateUser(requestParameters.updateUserDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createProfileImage operation in UserApi.
 * @export
 * @interface UserApiCreateProfileImageRequest
 */
export interface UserApiCreateProfileImageRequest {
    /**
     *
     * @type {File}
     * @memberof UserApiCreateProfileImage
     */
    readonly file: File
}

/**
 * Request parameters for createUser operation in UserApi.
 * @export
 * @interface UserApiCreateUserRequest
 */
export interface UserApiCreateUserRequest {
    /**
     *
     * @type {CreateUserDto}
     * @memberof UserApiCreateUser
     */
    readonly createUserDto: CreateUserDto
}

/**
 * Request parameters for deleteUser operation in UserApi.
 * @export
 * @interface UserApiDeleteUserRequest
 */
export interface UserApiDeleteUserRequest {
    /**
     *
     * @type {string}
     * @memberof UserApiDeleteUser
     */
    readonly id: string
}

/**
 * Request parameters for getAllUsers operation in UserApi.
 * @export
 * @interface UserApiGetAllUsersRequest
 */
export interface UserApiGetAllUsersRequest {
    /**
     *
     * @type {boolean}
     * @memberof UserApiGetAllUsers
     */
    readonly isAll: boolean
}

/**
 * Request parameters for getProfileImage operation in UserApi.
 * @export
 * @interface UserApiGetProfileImageRequest
 */
export interface UserApiGetProfileImageRequest {
    /**
     *
     * @type {string}
     * @memberof UserApiGetProfileImage
     */
    readonly id: string
}

/**
 * Request parameters for getUserById operation in UserApi.
 * @export
 * @interface UserApiGetUserByIdRequest
 */
export interface UserApiGetUserByIdRequest {
    /**
     *
     * @type {string}
     * @memberof UserApiGetUserById
     */
    readonly id: string
}

/**
 * Request parameters for restoreUser operation in UserApi.
 * @export
 * @interface UserApiRestoreUserRequest
 */
export interface UserApiRestoreUserRequest {
    /**
     *
     * @type {string}
     * @memberof UserApiRestoreUser
     */
    readonly id: string
}

/**
 * Request parameters for updateUser operation in UserApi.
 * @export
 * @interface UserApiUpdateUserRequest
 */
export interface UserApiUpdateUserRequest {
    /**
     *
     * @type {UpdateUserDto}
     * @memberof UserApiUpdateUser
     */
    readonly updateUserDto: UpdateUserDto
}

/**
 * UserApi - object-oriented interface
 * @export
 * @class UserApi
 * @extends {BaseAPI}
 */
export class UserApi extends BaseAPI {
    /**
     *
     * @param {UserApiCreateProfileImageRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public createProfileImage(requestParameters: UserApiCreateProfileImageRequest, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).createProfileImage(requestParameters.file, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {UserApiCreateUserRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public createUser(requestParameters: UserApiCreateUserRequest, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).createUser(requestParameters.createUserDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public deleteProfileImage(options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).deleteProfileImage(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {UserApiDeleteUserRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public deleteUser(requestParameters: UserApiDeleteUserRequest, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).deleteUser(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {UserApiGetAllUsersRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public getAllUsers(requestParameters: UserApiGetAllUsersRequest, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).getAllUsers(requestParameters.isAll, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public getMyUserInfo(options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).getMyUserInfo(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {UserApiGetProfileImageRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public getProfileImage(requestParameters: UserApiGetProfileImageRequest, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).getProfileImage(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {UserApiGetUserByIdRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public getUserById(requestParameters: UserApiGetUserByIdRequest, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).getUserById(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {UserApiRestoreUserRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public restoreUser(requestParameters: UserApiRestoreUserRequest, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).restoreUser(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {UserApiUpdateUserRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public updateUser(requestParameters: UserApiUpdateUserRequest, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).updateUser(requestParameters.updateUserDto, options).then((request) => request(this.axios, this.basePath));
    }
}


